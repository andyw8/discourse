# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `message_bus` gem.
# Please instead update this file by running `bin/tapioca gem message_bus`.

# @see MessageBus::Implementation
#
# source://message_bus//lib/message_bus/version.rb#3
module MessageBus
  extend ::MessageBus::Implementation
end

# source://message_bus//lib/message_bus.rb#23
MessageBus::BACKENDS = T.let(T.unsafe(nil), Hash)

# @see MessageBus::Backends::Base
#
# source://message_bus//lib/message_bus/backends.rb#5
module MessageBus::Backends; end

# Backends provide a consistent API over a variety of options for persisting
# published messages. The API they present is around the publication to and
# reading of messages from those backlogs in a manner consistent with
# message_bus' philosophy.
#
# The heart of the message bus, a backend acts as two things:
#
# 1. A channel multiplexer
# 2. Backlog storage per-multiplexed channel.
#
# Backends manage and expose multiple backlogs:
#
# * A backlog for each channel, in which messages that were published to
#   that channel are stored.
# * A global backlog, which conceptually stores all published messages,
#   regardless of the channel to which they were published.
#
# Backlog storage mechanisms and schemas are up to each individual backend
# implementation, and some backends store messages very differently than
# others. It is not necessary in order to be considered a valid backend,
# to, for example, store each channel backlog as a separate collection.
# As long as the API is presented per this documentation, the backend is
# free to make its own storage and performance optimisations.
#
# The concept of a per-channel backlog permits for lookups of messages in
# a manner that is optimised for the use case of a subscriber catching up
# from a message pointer, while a global backlog allows for optimising the
# case where another system subscribes to the firehose of messages, for
# example a message_bus server receiving all publications for delivery
# to subscribed clients.
#
# Backends are fully responsible for maintaining their storage, including
# any pruning or expiration of that storage that is necessary. message_bus
# allows for several options for limiting the required storage capacity
# by either backlog size or the TTL of messages in a backlog. Backends take
# these settings and effect them either forcibly or by delegating to their
# storage mechanism.
#
# Message which are published to message_bus have two IDs; one which they
# are known by in the channel-specific backlog that they are published to,
# and another (the "global ID") which is unique across all channels and by
# which the message can be found in the global backlog. IDs are all
# sequential integers starting at 0.
#
# @abstract
#
# source://message_bus//lib/message_bus/backends/base.rb#50
class MessageBus::Backends::Base
  # @param config [Hash] backend-specific configuration options; see the concrete class for details
  # @param max_backlog_size [Integer] the largest permitted size (number of messages) for per-channel backlogs; beyond this capacity, old messages will be dropped.
  # @return [Base] a new instance of Base
  #
  # source://message_bus//lib/message_bus/backends/base.rb#75
  def initialize(config = T.unsafe(nil), max_backlog_size = T.unsafe(nil)); end

  # Performs routines specific to the backend that are necessary after a process fork, typically triggered by a forking webserver. Typically this re-opens sockets to the backend.
  #
  # @raise [ConcreteClassMustImplementError]
  #
  # source://message_bus//lib/message_bus/backends/base.rb#78
  def after_fork; end

  # Get messages from a channel backlog
  #
  # @param channel [String] the name of the channel in question
  # @param last_id [#to_i] the channel-specific ID of the last message that the caller received on the specified channel
  # @raise [ConcreteClassMustImplementError]
  # @return [Array<MessageBus::Message>] all messages published to the specified channel since the specified last ID
  #
  # source://message_bus//lib/message_bus/backends/base.rb#136
  def backlog(channel, last_id = T.unsafe(nil)); end

  # Typically, backlogs are trimmed whenever we publish to them. This setting allows some tolerance in order to improve performance.
  #
  # @return [Integer] the interval of publications between which the backlog will not be cleared.
  #
  # source://message_bus//lib/message_bus/backends/base.rb#69
  def clear_every; end

  # Typically, backlogs are trimmed whenever we publish to them. This setting allows some tolerance in order to improve performance.
  #
  # @return [Integer] the interval of publications between which the backlog will not be cleared.
  #
  # source://message_bus//lib/message_bus/backends/base.rb#69
  def clear_every=(_arg0); end

  # Closes all open connections to the storage.
  #
  # @raise [ConcreteClassMustImplementError]
  #
  # source://message_bus//lib/message_bus/backends/base.rb#88
  def destroy; end

  # Deletes all backlogs and their data. Does not delete non-backlog data that message_bus may persist, depending on the concrete backend implementation. Use with extreme caution.
  #
  # @abstract
  # @raise [ConcreteClassMustImplementError]
  #
  # source://message_bus//lib/message_bus/backends/base.rb#94
  def expire_all_backlogs!; end

  # Get a specific message from a channel
  #
  # @param channel [String] the name of the channel in question
  # @param message_id [Integer] the channel-specific ID of the message required
  # @raise [ConcreteClassMustImplementError]
  # @return [MessageBus::Message, nil] the requested message, or nil if it does not exist
  #
  # source://message_bus//lib/message_bus/backends/base.rb#155
  def get_message(channel, message_id); end

  # Get messages from the global backlog
  #
  # @param last_id [#to_i] the global ID of the last message that the caller received
  # @raise [ConcreteClassMustImplementError]
  # @return [Array<MessageBus::Message>] all messages published on any channel since the specified last ID
  #
  # source://message_bus//lib/message_bus/backends/base.rb#145
  def global_backlog(last_id = T.unsafe(nil)); end

  # Subscribe to messages on all channels. Each message since the last ID
  # specified will be delivered by yielding to the passed block as soon as
  # it is available. This will block until subscription is terminated.
  #
  # @param last_id [#to_i] the global ID of the last message that the caller received
  # @raise [ConcreteClassMustImplementError]
  # @return [nil]
  # @yield [message] a message-handler block
  # @yieldparam message [MessageBus::Message] each message as it is delivered
  #
  # source://message_bus//lib/message_bus/backends/base.rb#189
  def global_subscribe(last_id = T.unsafe(nil)); end

  # Causes all subscribers to the bus to unsubscribe, and terminates the local connection. Typically used to reset tests.
  #
  # @raise [ConcreteClassMustImplementError]
  #
  # source://message_bus//lib/message_bus/backends/base.rb#175
  def global_unsubscribe; end

  # Get the ID of the last message published on a channel
  #
  # @param channel [String] the name of the channel in question
  # @raise [ConcreteClassMustImplementError]
  # @return [Integer] the channel-specific ID of the last message published to the given channel
  #
  # source://message_bus//lib/message_bus/backends/base.rb#117
  def last_id(channel); end

  # Get the ID of the last message published on multiple channels
  #
  # @param channels [Array<String>] - array of channels to fetch
  # @raise [ConcreteClassMustImplementError]
  # @return [Array<Integer>] the channel-specific IDs of the last message published to each requested channel
  #
  # source://message_bus//lib/message_bus/backends/base.rb#126
  def last_ids(*channels); end

  # @return [Integer] the longest amount of time a message may live in a backlog before being removed, in seconds.
  #
  # source://message_bus//lib/message_bus/backends/base.rb#66
  def max_backlog_age; end

  # @return [Integer] the longest amount of time a message may live in a backlog before being removed, in seconds.
  #
  # source://message_bus//lib/message_bus/backends/base.rb#66
  def max_backlog_age=(_arg0); end

  # @return [Integer] the largest permitted size (number of messages) for per-channel backlogs; beyond this capacity, old messages will be dropped.
  #
  # source://message_bus//lib/message_bus/backends/base.rb#62
  def max_backlog_size; end

  # @return [Integer] the largest permitted size (number of messages) for per-channel backlogs; beyond this capacity, old messages will be dropped.
  #
  # source://message_bus//lib/message_bus/backends/base.rb#62
  def max_backlog_size=(_arg0); end

  # @return [Integer] the largest permitted size (number of messages) for the global backlog; beyond this capacity, old messages will be dropped.
  #
  # source://message_bus//lib/message_bus/backends/base.rb#64
  def max_global_backlog_size; end

  # @return [Integer] the largest permitted size (number of messages) for the global backlog; beyond this capacity, old messages will be dropped.
  #
  # source://message_bus//lib/message_bus/backends/base.rb#64
  def max_global_backlog_size=(_arg0); end

  # @return [Integer] the largest permitted size (number of messages) to be held in a memory buffer when publication fails, for later re-publication.
  #
  # source://message_bus//lib/message_bus/backends/base.rb#71
  def max_in_memory_publish_backlog; end

  # @return [Integer] the largest permitted size (number of messages) to be held in a memory buffer when publication fails, for later re-publication.
  #
  # source://message_bus//lib/message_bus/backends/base.rb#71
  def max_in_memory_publish_backlog=(_arg0); end

  # Publishes a message to a channel
  #
  # @option opts
  # @option opts
  # @option opts
  # @param data [JSON] some data to publish to the channel. Must be an object that can be encoded as JSON
  # @param channel [String] the name of the channel to which the message should be published
  # @param opts [Hash]
  # @raise [ConcreteClassMustImplementError]
  # @return [Integer] the channel-specific ID the message was given
  #
  # source://message_bus//lib/message_bus/backends/base.rb#108
  def publish(channel, data, opts = T.unsafe(nil)); end

  # Deletes all message_bus data from the backend. Use with extreme caution.
  #
  # @raise [ConcreteClassMustImplementError]
  #
  # source://message_bus//lib/message_bus/backends/base.rb#83
  def reset!; end

  # Subscribe to messages on a particular channel. Each message since the
  # last ID specified will be delivered by yielding to the passed block as
  # soon as it is available. This will block until subscription is terminated.
  #
  # @param channel [String] the name of the channel to which we should subscribe
  # @param last_id [#to_i] the channel-specific ID of the last message that the caller received on the specified channel
  # @raise [ConcreteClassMustImplementError]
  # @return [nil]
  # @yield [message] a message-handler block
  # @yieldparam message [MessageBus::Message] each message as it is delivered
  #
  # source://message_bus//lib/message_bus/backends/base.rb#170
  def subscribe(channel, last_id = T.unsafe(nil)); end

  # @return [Boolean] The subscription state of the backend
  #
  # source://message_bus//lib/message_bus/backends/base.rb#60
  def subscribed; end
end

# Raised to indicate that the concrete backend implementation does not implement part of the API
#
# source://message_bus//lib/message_bus/backends/base.rb#54
class MessageBus::Backends::Base::ConcreteClassMustImplementError < ::StandardError; end

# @return [String] a special message published to trigger termination of backend subscriptions
#
# source://message_bus//lib/message_bus/backends/base.rb#57
MessageBus::Backends::Base::UNSUB_MESSAGE = T.let(T.unsafe(nil), String)

# source://message_bus//lib/message_bus.rb#26
class MessageBus::BusDestroyed < ::StandardError; end

# Represents a connected subscriber and delivers published messages over its
# connected socket.
#
# source://message_bus//lib/message_bus/client.rb#5
class MessageBus::Client
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param opts [Hash]
  # @return [Client] a new instance of Client
  #
  # source://message_bus//lib/message_bus/client.rb#38
  def initialize(opts); end

  # Delivers a message to the client, even if it's empty
  #
  # @param msg [MessageBus::Message, nil] the message to deliver
  # @return [void]
  #
  # source://message_bus//lib/message_bus/client.rb#121
  def <<(msg); end

  # @param msg [MessageBus::Message] the message in question
  # @return [Boolean] whether or not the client has permission to receive the
  #   passed message
  #
  # source://message_bus//lib/message_bus/client.rb#133
  def allowed?(msg); end

  # @return [Thin::AsyncResponse, nil]
  #
  # source://message_bus//lib/message_bus/client.rb#20
  def async_response; end

  # @return [Thin::AsyncResponse, nil]
  #
  # source://message_bus//lib/message_bus/client.rb#20
  def async_response=(_arg0); end

  # @return [Array<MessageBus::Message>] the set of messages the client is due
  #   to receive, based on its subscriptions and permissions. Includes status
  #   message if any channels have no messages available and the client
  #   requested a message newer than the newest on the channel, or when there
  #   are messages available that the client doesn't have permission for.
  #
  # source://message_bus//lib/message_bus/client.rb#177
  def backlog; end

  # @return [MessageBus::TimerThread::Cancelable] a timer job that is used to
  #   auto-disconnect the client at the configured long-polling interval
  #
  # source://message_bus//lib/message_bus/client.rb#18
  def cleanup_timer; end

  # @return [MessageBus::TimerThread::Cancelable] a timer job that is used to
  #   auto-disconnect the client at the configured long-polling interval
  #
  # source://message_bus//lib/message_bus/client.rb#18
  def cleanup_timer=(_arg0); end

  # @return [String] the unique ID provided by the client
  #
  # source://message_bus//lib/message_bus/client.rb#7
  def client_id; end

  # @return [String] the unique ID provided by the client
  #
  # source://message_bus//lib/message_bus/client.rb#7
  def client_id=(_arg0); end

  # Closes the client connection
  #
  # source://message_bus//lib/message_bus/client.rb#61
  def close; end

  # @return [Boolean] whether the connection is closed or not
  #
  # source://message_bus//lib/message_bus/client.rb#95
  def closed?; end

  # @return [Time] the time at which the client connected
  #
  # source://message_bus//lib/message_bus/client.rb#13
  def connect_time; end

  # @return [Time] the time at which the client connected
  #
  # source://message_bus//lib/message_bus/client.rb#13
  def connect_time=(_arg0); end

  # Delivers a backlog of messages to the client, if there is anything in it.
  # If chunked encoding/streaming is in use, will keep the connection open;
  # if not, will close it.
  #
  # @param backlog [Array<MessageBus::Message>] the set of messages to deliver
  # @return [void]
  #
  # source://message_bus//lib/message_bus/client.rb#76
  def deliver_backlog(backlog); end

  # If no data has yet been sent to the client, sends an empty chunk; prevents
  # clients from entering a timeout state if nothing is delivered initially.
  #
  # source://message_bus//lib/message_bus/client.rb#88
  def ensure_first_chunk_sent; end

  # @return [Array<String,Integer>] the group IDs the authenticated client is a member of
  #
  # source://message_bus//lib/message_bus/client.rb#11
  def group_ids; end

  # @return [Array<String,Integer>] the group IDs the authenticated client is a member of
  #
  # source://message_bus//lib/message_bus/client.rb#11
  def group_ids=(_arg0); end

  # @return [Hash<String => String>] custom headers to include in HTTP responses
  #
  # source://message_bus//lib/message_bus/client.rb#24
  def headers; end

  # @return [Hash<String => String>] custom headers to include in HTTP responses
  #
  # source://message_bus//lib/message_bus/client.rb#24
  def headers=(_arg0); end

  # @return [IO] the HTTP socket the client is connected on
  #
  # source://message_bus//lib/message_bus/client.rb#22
  def io; end

  # @return [IO] the HTTP socket the client is connected on
  #
  # source://message_bus//lib/message_bus/client.rb#22
  def io=(_arg0); end

  # @return [Integer] the connection sequence number the client provided when connecting
  #
  # source://message_bus//lib/message_bus/client.rb#26
  def seq; end

  # @return [Integer] the connection sequence number the client provided when connecting
  #
  # source://message_bus//lib/message_bus/client.rb#26
  def seq=(_arg0); end

  # @return [String] the site ID the client was authenticated for; used for hosting multiple
  #
  # source://message_bus//lib/message_bus/client.rb#15
  def site_id; end

  # @return [String] the site ID the client was authenticated for; used for hosting multiple
  #
  # source://message_bus//lib/message_bus/client.rb#15
  def site_id=(_arg0); end

  # Subscribes the client to messages on a channel, optionally from a
  # defined starting point.
  #
  # @param channel [String] the channel to subscribe to
  # @param last_seen_id [Integer, nil] the ID of the last message the client
  #   received. If nil, will be subscribed from the head of the backlog.
  # @return [void]
  #
  # source://message_bus//lib/message_bus/client.rb#106
  def subscribe(channel, last_seen_id); end

  # @return [Hash<String => Integer>] the active subscriptions, mapping channel
  #   names to last seen message IDs
  #
  # source://message_bus//lib/message_bus/client.rb#114
  def subscriptions; end

  # @return [void]
  # @yield executed with a lock on the Client instance
  #
  # source://message_bus//lib/message_bus/client.rb#56
  def synchronize; end

  # @return [Boolean] whether or not the client should use chunked encoding
  #
  # source://message_bus//lib/message_bus/client.rb#28
  def use_chunked; end

  # @return [Boolean] whether or not the client should use chunked encoding
  #
  # source://message_bus//lib/message_bus/client.rb#28
  def use_chunked=(_arg0); end

  # @return [String, Integer] the user ID the client was authenticated for
  #
  # source://message_bus//lib/message_bus/client.rb#9
  def user_id; end

  # @return [String, Integer] the user ID the client was authenticated for
  #
  # source://message_bus//lib/message_bus/client.rb#9
  def user_id=(_arg0); end

  private

  # source://message_bus//lib/message_bus/client.rb#304
  def ensure_closed!; end

  # @return [Boolean]
  #
  # source://message_bus//lib/message_bus/client.rb#332
  def in_async?; end

  # source://message_bus//lib/message_bus/client.rb#328
  def messages_to_json(msgs); end

  # source://message_bus//lib/message_bus/client.rb#286
  def write_and_close(data); end

  # source://message_bus//lib/message_bus/client.rb#257
  def write_chunk(data); end

  # source://message_bus//lib/message_bus/client.rb#239
  def write_headers; end
end

# source://message_bus//lib/message_bus/client.rb#233
MessageBus::Client::CHUNKED_ENCODING = T.let(T.unsafe(nil), String)

# source://message_bus//lib/message_bus/client.rb#229
MessageBus::Client::COLON_SPACE = T.let(T.unsafe(nil), String)

# source://message_bus//lib/message_bus/client.rb#232
MessageBus::Client::CONNECTION_CLOSE = T.let(T.unsafe(nil), String)

# source://message_bus//lib/message_bus/client.rb#231
MessageBus::Client::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://message_bus//lib/message_bus/client.rb#230
MessageBus::Client::HTTP_11 = T.let(T.unsafe(nil), String)

# heavily optimised to avoid all unneeded allocations
#
# source://message_bus//lib/message_bus/client.rb#228
MessageBus::Client::NEWLINE = T.let(T.unsafe(nil), String)

# source://message_bus//lib/message_bus/client.rb#234
MessageBus::Client::NO_SNIFF = T.let(T.unsafe(nil), String)

# source://message_bus//lib/message_bus/client.rb#237
MessageBus::Client::TYPE_JSON = T.let(T.unsafe(nil), String)

# source://message_bus//lib/message_bus/client.rb#236
MessageBus::Client::TYPE_TEXT = T.let(T.unsafe(nil), String)

# source://message_bus//lib/message_bus/codec/base.rb#4
module MessageBus::Codec; end

# source://message_bus//lib/message_bus/codec/base.rb#5
class MessageBus::Codec::Base
  # @raise [ConcreteClassMustImplementError]
  #
  # source://message_bus//lib/message_bus/codec/base.rb#10
  def decode(payload); end

  # @raise [ConcreteClassMustImplementError]
  #
  # source://message_bus//lib/message_bus/codec/base.rb#6
  def encode(hash); end
end

# source://message_bus//lib/message_bus/codec/json.rb#5
class MessageBus::Codec::Json < ::MessageBus::Codec::Base
  # source://message_bus//lib/message_bus/codec/json.rb#10
  def decode(payload); end

  # source://message_bus//lib/message_bus/codec/json.rb#6
  def encode(hash); end
end

# source://message_bus//lib/message_bus/codec/oj.rb#7
class MessageBus::Codec::Oj < ::MessageBus::Codec::Base
  # @return [Oj] a new instance of Oj
  #
  # source://message_bus//lib/message_bus/codec/oj.rb#8
  def initialize(options = T.unsafe(nil)); end

  # source://message_bus//lib/message_bus/codec/oj.rb#16
  def decode(payload); end

  # source://message_bus//lib/message_bus/codec/oj.rb#12
  def encode(hash); end
end

# Manages a set of subscribers with active connections to the server, such that
# messages which are published during the connection may be dispatched.
#
# source://message_bus//lib/message_bus/connection_manager.rb#7
class MessageBus::ConnectionManager
  include ::MonitorMixin

  # @param bus [MessageBus::Instance] the message bus for which to manage connections
  # @return [ConnectionManager] a new instance of ConnectionManager
  #
  # source://message_bus//lib/message_bus/connection_manager.rb#12
  def initialize(bus = T.unsafe(nil)); end

  # Keeps track of a client with an active connection
  #
  # @param client [MessageBus::Client] the client to track
  # @return [void]
  #
  # source://message_bus//lib/message_bus/connection_manager.rb#53
  def add_client(client); end

  # @return [Integer] the number of tracked clients
  #
  # source://message_bus//lib/message_bus/connection_manager.rb#99
  def client_count; end

  # Finds a client by ID
  #
  # @param client_id [String] the client ID to search by
  # @return [MessageBus::Client] the client with the specified ID
  #
  # source://message_bus//lib/message_bus/connection_manager.rb#92
  def lookup_client(client_id); end

  # Dispatches a message to any connected clients which are permitted to receive it
  #
  # @param msg [MessageBus::Message] the message to dispatch
  # @return [void]
  #
  # source://message_bus//lib/message_bus/connection_manager.rb#22
  def notify_clients(msg); end

  # Removes a client
  #
  # @param c [MessageBus::Client] the client to remove
  # @return [void]
  #
  # source://message_bus//lib/message_bus/connection_manager.rb#76
  def remove_client(c); end

  private

  # source://message_bus//lib/message_bus/connection_manager.rb#107
  def subscribe_client(client, channel); end
end

# Like a hash, just does its best to stay in sync across the farm.
# On boot all instances are blank, but they populate as various processes
# fill it up.
#
# source://message_bus//lib/message_bus/distributed_cache.rb#11
class MessageBus::DistributedCache
  # @return [DistributedCache] a new instance of DistributedCache
  #
  # source://message_bus//lib/message_bus/distributed_cache.rb#118
  def initialize(key, manager: T.unsafe(nil), namespace: T.unsafe(nil), app_version: T.unsafe(nil)); end

  # source://message_bus//lib/message_bus/distributed_cache.rb#141
  def [](k); end

  # source://message_bus//lib/message_bus/distributed_cache.rb#135
  def []=(k, v); end

  # source://message_bus//lib/message_bus/distributed_cache.rb#152
  def clear; end

  # source://message_bus//lib/message_bus/distributed_cache.rb#146
  def delete(k, publish: T.unsafe(nil)); end

  # source://message_bus//lib/message_bus/distributed_cache.rb#157
  def hash(site_id_arg = T.unsafe(nil)); end

  # source://message_bus//lib/message_bus/distributed_cache.rb#130
  def identity; end

  # Returns the value of attribute key.
  #
  # source://message_bus//lib/message_bus/distributed_cache.rb#116
  def key; end

  class << self
    # source://message_bus//lib/message_bus/distributed_cache.rb#112
    def default_manager; end
  end
end

# source://message_bus//lib/message_bus/distributed_cache.rb#12
MessageBus::DistributedCache::DEFAULT_SITE_ID = T.let(T.unsafe(nil), String)

# source://message_bus//lib/message_bus/distributed_cache.rb#14
class MessageBus::DistributedCache::Manager
  # @return [Manager] a new instance of Manager
  #
  # source://message_bus//lib/message_bus/distributed_cache.rb#19
  def initialize(message_bus = T.unsafe(nil), publish_queue_in_memory: T.unsafe(nil)); end

  # Returns the value of attribute app_version.
  #
  # source://message_bus//lib/message_bus/distributed_cache.rb#17
  def app_version; end

  # Sets the attribute app_version
  #
  # @param value the value to set the attribute app_version to.
  #
  # source://message_bus//lib/message_bus/distributed_cache.rb#17
  def app_version=(_arg0); end

  # source://message_bus//lib/message_bus/distributed_cache.rb#99
  def clear(hash); end

  # source://message_bus//lib/message_bus/distributed_cache.rb#95
  def delete(hash, key); end

  # source://message_bus//lib/message_bus/distributed_cache.rb#62
  def ensure_subscribe!; end

  # source://message_bus//lib/message_bus/distributed_cache.rb#32
  def process_message(message); end

  # source://message_bus//lib/message_bus/distributed_cache.rb#77
  def publish(hash, message); end

  # source://message_bus//lib/message_bus/distributed_cache.rb#103
  def register(hash); end

  # source://message_bus//lib/message_bus/distributed_cache.rb#88
  def set(hash, key, value); end

  # source://message_bus//lib/message_bus/distributed_cache.rb#28
  def subscribers; end
end

# source://message_bus//lib/message_bus/distributed_cache.rb#15
MessageBus::DistributedCache::Manager::CHANNEL_NAME = T.let(T.unsafe(nil), String)

# The main server-side interface to a message bus for the purposes of
# configuration, publishing and subscribing
#
# source://message_bus//lib/message_bus.rb#30
module MessageBus::Implementation
  # source://message_bus//lib/message_bus.rb#39
  def initialize; end

  # Performs routines that are necessary after a process fork, typically
  #   triggered by a forking webserver. Performs whatever the backend requires
  #   and ensures the server is listening for publications and running
  #   scheduled tasks.
  #
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#559
  def after_fork; end

  # @param val [Boolean] whether or not to allow broadcasting (debugging)
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#260
  def allow_broadcast=(val); end

  # @return [Boolean] whether or not broadcasting is allowed. If not explicitly
  #   set, defaults to false unless we're in Rails test or development mode.
  #
  # source://message_bus//lib/message_bus.rb#266
  def allow_broadcast?; end

  # @return [Symbol] the name of the backend implementation configured
  #
  # source://message_bus//lib/message_bus.rb#321
  def backend; end

  # @return [MessageBus::Backend::Base] the configured backend. If not
  #   explicitly set, will be loaded based on the configuration provided.
  #
  # source://message_bus//lib/message_bus.rb#299
  def backend_instance; end

  # @param backend_instance [MessageBus::Backend::Base] A configured backend
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#288
  def backend_instance=(backend_instance); end

  # Get messages from a channel backlog since the last ID specified, filtered by site
  #
  # @param channel [String] the name of the channel in question
  # @param last_id [#to_i] the channel-specific ID of the last message that the caller received on the specified channel
  # @param site_id [String] the ID of the site by which to filter
  # @return [Array<MessageBus::Message>] all messages published to the specified channel since the specified last ID
  #
  # source://message_bus//lib/message_bus.rb#485
  def backlog(channel = T.unsafe(nil), last_id = T.unsafe(nil), site_id = T.unsafe(nil)); end

  # @return [String] the route that message bus will respond to. If not
  #   explicitly set, defaults to "/". Requests to "#{base_route}message-bus/*" will be handled
  #   by the message bus server.
  #
  # source://message_bus//lib/message_bus.rb#154
  def base_route; end

  # @param route [String] Message bus will listen to requests on this route.
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#147
  def base_route=(route); end

  # Subscribe to messages. Each message will be delivered by yielding to the
  # passed block as soon as it is available. This will block until subscription
  # is terminated.
  #
  # @param channel [String, nil] the name of the channel to which we should
  #   subscribe. If `nil`, messages on every channel will be provided.
  # @return [void]
  # @yield [message] a message-handler block
  # @yieldparam message [MessageBus::Message] each message as it is delivered
  #
  # source://message_bus//lib/message_bus.rb#405
  def blocking_subscribe(channel = T.unsafe(nil), &blk); end

  # @param val [Boolean] whether or not to enable chunked encoding
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#75
  def chunked_encoding_enabled=(val); end

  # @return [Boolean] whether or not chunked encoding is enabled. If not
  #   explicitly set, defaults to true.
  #
  # source://message_bus//lib/message_bus.rb#69
  def chunked_encoding_enabled?; end

  # @return [Array] returns a hash of message filters that have been registered
  #
  # source://message_bus//lib/message_bus.rb#619
  def client_message_filters; end

  # @return [Hash<Symbol => Object>] Configuration options hash
  #
  # source://message_bus//lib/message_bus.rb#32
  def config; end

  # Overrides existing configuration
  #
  # @param config [Hash<Symbol => Object>] values to merge into existing config
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#180
  def configure(config); end

  # Stops listening for publications and stops executing scheduled tasks.
  # Mostly used in tests to destroy entire bus.
  #
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#538
  def destroy; end

  # @return [void]
  # @yield [env] a routine to determine extra headers to be set on a subscriber response
  # @yieldparam env [Rack::Request::Env] the subscriber request environment
  # @yieldreturn [Hash<String => String>] the extra headers to set on the response
  #
  # source://message_bus//lib/message_bus.rb#243
  def extra_response_headers_lookup(&blk); end

  # Get messages from the global backlog since the last ID specified
  #
  # @param last_id [#to_i] the global ID of the last message that the caller received
  # @return [Array<MessageBus::Message>] all messages published on any channel since the specified last ID
  #
  # source://message_bus//lib/message_bus.rb#474
  def global_backlog(last_id = T.unsafe(nil)); end

  # @return [void]
  # @yield [env] a routine to determine the group IDs for a subscriber
  # @yieldparam env [optional, Rack::Request::Env] the subscriber request environment
  # @yieldreturn [optional, Array<String,Integer>] the group IDs for the subscriber
  #
  # source://message_bus//lib/message_bus.rb#215
  def group_ids_lookup(&blk); end

  # @return [void]
  # @yield [env] a routine to determine if a request comes from an admin user
  # @yieldparam env [Rack::Request::Env] the subscriber request environment
  # @yieldreturn [Boolean] whether or not the request is from an admin user
  #
  # source://message_bus//lib/message_bus.rb#224
  def is_admin_lookup(&blk); end

  # @return [Integer] the keepalive interval in seconds. If not explicitly set,
  #   defaults to `60`.
  #
  # source://message_bus//lib/message_bus.rb#600
  def keepalive_interval; end

  # @param interval [Integer] the keepalive interval in seconds.
  #   Set to 0 to disable; anything higher and a keepalive will run every N
  #   seconds. If it fails, the process is killed.
  #
  # source://message_bus//lib/message_bus.rb#594
  def keepalive_interval=(interval); end

  # Get the ID of the last message published on a channel, filtered by site
  #
  # @param channel [String] the name of the channel in question
  # @param site_id [String] the ID of the site by which to filter
  # @return [Integer] the channel-specific ID of the last message published to the given channel
  #
  # source://message_bus//lib/message_bus.rb#505
  def last_id(channel, site_id = T.unsafe(nil)); end

  # Get the ID of the last message published on multiple channels
  #
  # @param channels [Array<String>] - array of channels to fetch
  # @param site_id [String] - the ID of the site by which to filter
  # @return [Hash] the channel-specific IDs of the last message published to each requested channel
  #
  # source://message_bus//lib/message_bus.rb#515
  def last_ids(*channels, site_id: T.unsafe(nil)); end

  # Get the last message published on a channel
  #
  # @param channel [String] the name of the channel in question
  # @return [MessageBus::Message] the last message published to the given channel
  #
  # source://message_bus//lib/message_bus.rb#526
  def last_message(channel); end

  # @return [Boolean] whether or not the server is actively listening for
  #   publications on the bus
  #
  # source://message_bus//lib/message_bus.rb#568
  def listening?; end

  # Subscribe to messages on a particular channel, filtered by the current site
  # (@see #site_id_lookup). Each message since the last ID specified will be
  # delivered by yielding to the passed block as soon as it is available. This
  # will not block, but instead the callbacks will be executed asynchronously
  # in a dedicated subscriber thread.
  #
  # @param channel [String] the name of the channel to which we should subscribe
  # @param last_id [#to_i] the channel-specific ID of the last message that the caller received on the specified channel
  # @return [Proc] the callback block that will be executed
  # @yield [message] a message-handler block
  # @yieldparam message [MessageBus::Message] each message as it is delivered
  #
  # source://message_bus//lib/message_bus.rb#442
  def local_subscribe(channel = T.unsafe(nil), last_id = T.unsafe(nil), &blk); end

  # Removes a subscription to a particular channel, filtered by the current site
  # (@see #site_id_lookup).
  #
  # @param channel [String] the name of the channel from which we should unsubscribe
  # @param blk [Proc, nil] the callback which should be removed. If `nil`, removes all.
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#464
  def local_unsubscribe(channel = T.unsafe(nil), &blk); end

  # @return [Logger] the logger used by the bus. If not explicitly set,
  #   is configured to log to STDOUT at INFO level.
  #
  # source://message_bus//lib/message_bus.rb#57
  def logger; end

  # @param logger [Logger] a logger object to be used by the bus
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#51
  def logger=(logger); end

  # @param val [Boolean] whether or not to enable long polling
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#87
  def long_polling_enabled=(val); end

  # @return [Boolean] whether or not long polling is enabled. If not explicitly
  #   set, defaults to true.
  #
  # source://message_bus//lib/message_bus.rb#81
  def long_polling_enabled?; end

  # @return [Integer] the long-polling interval in milliseconds. If not
  #   explicitly set, defaults to 25,000.
  #
  # source://message_bus//lib/message_bus.rb#141
  def long_polling_interval; end

  # @param millisecs [Integer] the long-polling interval in milliseconds
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#135
  def long_polling_interval=(millisecs); end

  # @return [Integer] The number of simultaneous clients we can service;
  #   will revert to polling if we are out of slots. Defaults to 1000 if not
  #   explicitly set.
  #
  # source://message_bus//lib/message_bus.rb#101
  def max_active_clients; end

  # @param val [Integer] The number of simultaneous clients we can service;
  #   will revert to polling if we are out of slots
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#94
  def max_active_clients=(val); end

  # Disables publication to the bus
  #
  # @param disable_publish [Boolean] Whether or not to disable publishing
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#166
  def off(disable_publish: T.unsafe(nil)); end

  # @return [Boolean] whether the bus is disabled or not
  #
  # source://message_bus//lib/message_bus.rb#159
  def off?; end

  # Enables publication to the bus
  #
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#173
  def on; end

  # source://message_bus//lib/message_bus.rb#248
  def on_connect(&blk); end

  # source://message_bus//lib/message_bus.rb#253
  def on_disconnect(&blk); end

  # @return [void]
  # @yield [env, e] a routine to handle exceptions raised when handling a subscriber request
  # @yieldparam env [Rack::Request::Env] the subscriber request environment
  # @yieldparam e [Exception] the exception that was raised
  # @yieldreturn [optional, Array<(Integer,Hash,Array)>] a Rack response to be delivered
  #
  # source://message_bus//lib/message_bus.rb#234
  def on_middleware_error(&blk); end

  # Publishes a message to a channel
  #
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param channel [String] the name of the channel to which the message should be published
  # @param data [JSON] some data to publish to the channel. Must be an object that can be encoded as JSON
  # @param opts [Hash]
  # @raise [MessageBus::BusDestroyed] if the bus is destroyed
  # @raise [MessageBus::InvalidMessage] if attempting to put permission restrictions on a globally-published message
  # @raise [MessageBus::InvalidMessageTarget] if attempting to publish to a empty group of users
  # @return [Integer] the channel-specific ID the message was given
  #
  # source://message_bus//lib/message_bus.rb#343
  def publish(channel, data, opts = T.unsafe(nil)); end

  # @param val [Boolean] whether or not to enable Rack Hijack
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#129
  def rack_hijack_enabled=(val); end

  # @return [Boolean] whether or not Rack Hijack is enabled. If not explicitly
  #   set, will default to true, unless we're on Passenger without the ability
  #   to set the advertised_concurrency_level to 0.
  #
  # source://message_bus//lib/message_bus.rb#108
  def rack_hijack_enabled?; end

  # @return [Hash<Symbol => Object>] Configuration options hash
  def redis_config; end

  # Overrides existing configuration, explicitly enabling the redis backend
  #
  # @param config [Hash<Symbol => Object>] values to merge into existing config
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#187
  def redis_config=(config); end

  # Registers a client message filter that allows messages to be filtered from the client.
  #
  # @param channel_prefix [String, Regexp] channel prefix to match against a message's channel
  # @return [void]
  # @yieldparam message [MessageBus::Message] published to the channel that matched the prefix provided
  # @yieldreturn [Boolean] whether the message should be published to the client
  #
  # source://message_bus//lib/message_bus.rb#611
  def register_client_message_filter(channel_prefix, &blk); end

  # source://message_bus//lib/message_bus.rb#315
  def reliable_pub_sub; end

  # source://message_bus//lib/message_bus.rb#292
  def reliable_pub_sub=(pub_sub); end

  # source://message_bus//lib/message_bus.rb#573
  def reset!; end

  # @return [void]
  # @yield [env] a routine to determine the site ID for a subscriber
  # @yieldparam env [optional, Rack::Request::Env] the subscriber request environment
  # @yieldreturn [optional, String] the site ID for the subscriber
  #
  # source://message_bus//lib/message_bus.rb#197
  def site_id_lookup(&blk); end

  # Subscribe to messages on a particular channel. Each message since the
  # last ID specified will be delivered by yielding to the passed block as
  # soon as it is available. This will not block, but instead the callbacks
  # will be executed asynchronously in a dedicated subscriber thread.
  #
  # @param channel [String] the name of the channel to which we should subscribe
  # @param last_id [#to_i] the channel-specific ID of the last message that the caller received on the specified channel
  # @return [Proc] the callback block that will be executed
  # @yield [message] a message-handler block
  # @yieldparam message [MessageBus::Message] each message as it is delivered
  #
  # source://message_bus//lib/message_bus.rb#425
  def subscribe(channel = T.unsafe(nil), last_id = T.unsafe(nil), &blk); end

  # @return [MessageBus::TimerThread] the timer thread used for triggering
  #   scheduled routines at specific times/intervals.
  #
  # source://message_bus//lib/message_bus.rb#579
  def timer; end

  # @return [MessageBus::Codec::Base] codec used to encode and decode Message payloads
  #
  # source://message_bus//lib/message_bus.rb#282
  def transport_codec; end

  # @param codec [MessageBus::Codec::Base] used to encode and decode Message payloads
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#277
  def transport_codec=(codec); end

  # Removes a subscription to a particular channel.
  #
  # @param channel [String] the name of the channel from which we should unsubscribe
  # @param blk [Proc, nil] the callback which should be removed. If `nil`, removes all.
  # @return [void]
  #
  # source://message_bus//lib/message_bus.rb#453
  def unsubscribe(channel = T.unsafe(nil), &blk); end

  # @return [void]
  # @yield [env] a routine to determine the user ID for a subscriber (authenticate)
  # @yieldparam env [optional, Rack::Request::Env] the subscriber request environment
  # @yieldreturn [optional, String, Integer] the user ID for the subscriber
  #
  # source://message_bus//lib/message_bus.rb#206
  def user_id_lookup(&blk); end

  private

  # source://message_bus//lib/message_bus.rb#639
  def decode_channel_name(channel); end

  # source://message_bus//lib/message_bus.rb#647
  def decode_message!(msg); end

  # encode channel name to include site
  #
  # source://message_bus//lib/message_bus.rb#629
  def encode_channel_name(channel, site_id = T.unsafe(nil)); end

  # source://message_bus//lib/message_bus.rb#719
  def ensure_subscriber_thread; end

  # @return [Boolean]
  #
  # source://message_bus//lib/message_bus.rb#643
  def global?(channel); end

  # source://message_bus//lib/message_bus.rb#765
  def global_subscribe_thread; end

  # source://message_bus//lib/message_bus.rb#802
  def multi_each(*args, &block); end

  # source://message_bus//lib/message_bus.rb#736
  def new_subscriber_thread; end

  # source://message_bus//lib/message_bus.rb#658
  def replay_backlog(channel, last_id, site_id); end

  # @raise [MessageBus::BusDestroyed]
  #
  # source://message_bus//lib/message_bus.rb#669
  def subscribe_impl(channel, site_id, last_id, &blk); end

  # source://message_bus//lib/message_bus.rb#709
  def unsubscribe_impl(channel, site_id, &blk); end
end

# source://message_bus//lib/message_bus.rb#626
MessageBus::Implementation::ENCODE_SITE_TOKEN = T.let(T.unsafe(nil), String)

# source://message_bus//lib/message_bus.rb#734
MessageBus::Implementation::MIN_KEEPALIVE = T.let(T.unsafe(nil), Integer)

# Like Mutex but safe for recursive calls
#
# source://message_bus//lib/message_bus.rb#35
class MessageBus::Implementation::Synchronizer
  include ::MonitorMixin
end

# allows for multiple buses per app
#
# @see MessageBus::Implementation
#
# source://message_bus//lib/message_bus.rb#816
class MessageBus::Instance
  include ::MessageBus::Implementation
end

# source://message_bus//lib/message_bus.rb#24
class MessageBus::InvalidMessage < ::StandardError; end

# source://message_bus//lib/message_bus.rb#25
class MessageBus::InvalidMessageTarget < ::MessageBus::InvalidMessage; end

# Represents a published message and its encoding for persistence.
#
# source://message_bus//lib/message_bus/message.rb#4
class MessageBus::Message < ::Struct
  # Returns the value of attribute client_ids.
  #
  # source://message_bus//lib/message_bus/message.rb#5
  def client_ids; end

  # Sets the attribute client_ids
  #
  # @param value the value to set the attribute client_ids to.
  #
  # source://message_bus//lib/message_bus/message.rb#5
  def client_ids=(_arg0); end

  # only tricky thing to encode is pipes in a channel name ... do a straight replace
  #
  # source://message_bus//lib/message_bus/message.rb#22
  def encode; end

  # source://message_bus//lib/message_bus/message.rb#26
  def encode_without_ids; end

  # Returns the value of attribute group_ids.
  #
  # source://message_bus//lib/message_bus/message.rb#5
  def group_ids; end

  # Sets the attribute group_ids
  #
  # @param value the value to set the attribute group_ids to.
  #
  # source://message_bus//lib/message_bus/message.rb#5
  def group_ids=(_arg0); end

  # Returns the value of attribute site_id.
  #
  # source://message_bus//lib/message_bus/message.rb#5
  def site_id; end

  # Sets the attribute site_id
  #
  # @param value the value to set the attribute site_id to.
  #
  # source://message_bus//lib/message_bus/message.rb#5
  def site_id=(_arg0); end

  # Returns the value of attribute user_ids.
  #
  # source://message_bus//lib/message_bus/message.rb#5
  def user_ids; end

  # Sets the attribute user_ids
  #
  # @param value the value to set the attribute user_ids to.
  #
  # source://message_bus//lib/message_bus/message.rb#5
  def user_ids=(_arg0); end

  class << self
    # source://message_bus//lib/message_bus/message.rb#7
    def decode(encoded); end
  end
end

# our little message bus, accepts long polling and polling
#
# source://message_bus//lib/message_bus/rack/middleware.rb#6
module MessageBus::Rack; end

# Accepts requests from subscribers, validates and authenticates them,
# delivers existing messages from the backlog and informs a
# `MessageBus::ConnectionManager` of a connection which is remaining open.
#
# source://message_bus//lib/message_bus/rack/middleware.rb#11
class MessageBus::Rack::Middleware
  # Sets up the middleware to receive subscriber client requests and begins
  # listening for messages published on the bus for re-distribution (unless
  # the bus is disabled).
  #
  # @option config
  # @param app [Proc] the rack app
  # @param config [Hash]
  # @return [Middleware] a new instance of Middleware
  #
  # source://message_bus//lib/message_bus/rack/middleware.rb#37
  def initialize(app, config = T.unsafe(nil)); end

  # Process an HTTP request from a subscriber client
  #
  # @param env [Rack::Request::Env] the request environment
  #
  # source://message_bus//lib/message_bus/rack/middleware.rb#59
  def call(env); end

  # @return [Boolean] whether the message listener (subscriber) is started or not)
  #
  # source://message_bus//lib/message_bus/rack/middleware.rb#28
  def started_listener; end

  # Stops listening for messages on the bus
  #
  # @return [void]
  #
  # source://message_bus//lib/message_bus/rack/middleware.rb#50
  def stop_listener; end

  private

  # source://message_bus//lib/message_bus/rack/middleware.rb#209
  def add_client_with_timeout(client); end

  # source://message_bus//lib/message_bus/rack/middleware.rb#197
  def close_db_connection!; end

  # source://message_bus//lib/message_bus/rack/middleware.rb#67
  def handle_request(env); end

  # source://message_bus//lib/message_bus/rack/middleware.rb#222
  def start_listener; end

  class << self
    # @param backlog [Array<MessageBus::Message>] a list of messages for delivery
    # @return [JSON] a JSON representation of the backlog, compliant with the
    #   subscriber API specification
    #
    # source://message_bus//lib/message_bus/rack/middleware.rb#15
    def backlog_to_json(backlog); end
  end
end

# source://message_bus//lib/message_bus/rails/railtie.rb#3
module MessageBus::Rails; end

# rails engine for asset pipeline
#
# source://message_bus//lib/message_bus/rails/railtie.rb#6
class MessageBus::Rails::Engine < ::Rails::Engine
  class << self
    # source://activesupport/7.0.7/lib/active_support/callbacks.rb#68
    def __callbacks; end
  end
end

# source://message_bus//lib/message_bus/rails/railtie.rb#8
class MessageBus::Rails::Railtie < ::Rails::Railtie
  # @return [Boolean]
  #
  # source://message_bus//lib/message_bus/rails/railtie.rb#33
  def api_only?(config); end

  # @return [Boolean]
  #
  # source://message_bus//lib/message_bus/rails/railtie.rb#27
  def skip_middleware?(config); end
end

# source://message_bus//lib/message_bus/timer_thread.rb#3
class MessageBus::TimerThread
  # @return [TimerThread] a new instance of TimerThread
  #
  # source://message_bus//lib/message_bus/timer_thread.rb#33
  def initialize; end

  # source://message_bus//lib/message_bus/timer_thread.rb#61
  def every(delay, &block); end

  # Returns the value of attribute jobs.
  #
  # source://message_bus//lib/message_bus/timer_thread.rb#4
  def jobs; end

  # source://message_bus//lib/message_bus/timer_thread.rb#106
  def on_error(&block); end

  # queue a block to run after a certain delay (in seconds)
  #
  # source://message_bus//lib/message_bus/timer_thread.rb#75
  def queue(delay = T.unsafe(nil), &block); end

  # source://message_bus//lib/message_bus/timer_thread.rb#42
  def stop; end

  protected

  # source://message_bus//lib/message_bus/timer_thread.rb#112
  def do_work; end
end

# source://message_bus//lib/message_bus/timer_thread.rb#6
class MessageBus::TimerThread::Cancelable
  # @return [Cancelable] a new instance of Cancelable
  #
  # source://message_bus//lib/message_bus/timer_thread.rb#16
  def initialize(job); end

  # source://message_bus//lib/message_bus/timer_thread.rb#20
  def cancel; end
end

# usually you could just use a blank lambda
# but an object is ever so slightly faster
#
# source://message_bus//lib/message_bus/timer_thread.rb#14
MessageBus::TimerThread::Cancelable::NOOP = T.let(T.unsafe(nil), MessageBus::TimerThread::Cancelable::NoOp)

# source://message_bus//lib/message_bus/timer_thread.rb#7
class MessageBus::TimerThread::Cancelable::NoOp
  # source://message_bus//lib/message_bus/timer_thread.rb#8
  def call; end
end

# source://message_bus//lib/message_bus/timer_thread.rb#25
class MessageBus::TimerThread::CancelableEvery
  # source://message_bus//lib/message_bus/timer_thread.rb#27
  def cancel; end

  # Returns the value of attribute cancelled.
  #
  # source://message_bus//lib/message_bus/timer_thread.rb#26
  def cancelled; end

  # Sets the attribute cancelled
  #
  # @param value the value to set the attribute cancelled to.
  #
  # source://message_bus//lib/message_bus/timer_thread.rb#26
  def cancelled=(_arg0); end

  # Returns the value of attribute current.
  #
  # source://message_bus//lib/message_bus/timer_thread.rb#26
  def current; end

  # Sets the attribute current
  #
  # @param value the value to set the attribute current to.
  #
  # source://message_bus//lib/message_bus/timer_thread.rb#26
  def current=(_arg0); end
end

# source://message_bus//lib/message_bus/version.rb#4
MessageBus::VERSION = T.let(T.unsafe(nil), String)
