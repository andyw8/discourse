# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `fakeweb` gem.
# Please instead update this file by running `bin/tapioca gem fakeweb`.

# source://fakeweb//lib/fake_web/registry.rb#1
module FakeWeb
  class << self
    # Enables or disables real HTTP connections for requests that don't match
    # registered URIs.
    #
    # If you set <tt>FakeWeb.allow_net_connect = false</tt> and subsequently try
    # to make a request to a URI you haven't registered with #register_uri, a
    # NetConnectNotAllowedError will be raised. This is handy when you want to
    # make sure your tests are self-contained, or want to catch the scenario
    # when a URI is changed in implementation code without a corresponding test
    # change.
    #
    # When <tt>FakeWeb.allow_net_connect = true</tt> (the default), requests to
    # URIs not stubbed with FakeWeb are passed through to Net::HTTP.
    #
    # If you assign a +String+, +URI+, or +Regexp+ object, unstubbed requests
    # will be allowed if they match that value. This is useful when you want to
    # allow access to a local server for integration testing, while still
    # preventing your tests from using the internet.
    #
    # source://fakeweb//lib/fake_web.rb#41
    def allow_net_connect=(allowed); end

    # Returns +true+ if requests to URIs not registered with FakeWeb are passed
    # through to Net::HTTP for normal processing (the default). Returns +false+
    # if an exception is raised for these requests.
    #
    # If you've assigned a +String+, +URI+, or +Regexp+ to
    # <tt>FakeWeb.allow_net_connect=</tt>, you must supply a URI to check
    # against that filter. Otherwise, an ArgumentError will be raised.
    #
    # @return [Boolean]
    #
    # source://fakeweb//lib/fake_web.rb#62
    def allow_net_connect?(uri = T.unsafe(nil)); end

    # Resets the FakeWeb Registry. This will force all subsequent web requests to
    # behave as real requests.
    #
    # source://fakeweb//lib/fake_web.rb#20
    def clean_registry; end

    # Returns the request object from the last request made via Net::HTTP.
    #
    # source://fakeweb//lib/fake_web.rb#196
    def last_request; end

    # source://fakeweb//lib/fake_web.rb#200
    def last_request=(request); end

    # source://fakeweb//lib/fake_web.rb#206
    def print_missing_http_method_deprecation_warning(*args); end

    # call-seq:
    #   FakeWeb.register_uri(method, uri, options)
    #
    # Register requests using the HTTP method specified by the symbol +method+
    # for +uri+ to be handled according to +options+. If you specify the method
    # <tt>:any</tt>, the response will be reigstered for any request for +uri+.
    # +uri+ can be a +String+, +URI+, or +Regexp+ object. +options+ must be either
    # a +Hash+ or an +Array+ of +Hashes+ (see below), which must contain one of
    # these two keys:
    #
    # <tt>:body</tt>::
    #   A string which is used as the body of the response. If the string refers
    #   to a valid filesystem path, the contents of that file will be read and used
    #   as the body of the response instead. (This used to be two options,
    #   <tt>:string</tt> and <tt>:file</tt>, respectively. These are now deprecated.)
    # <tt>:response</tt>::
    #   Either a <tt>Net::HTTPResponse</tt>, an +IO+, or a +String+ which is used
    #   as the full response for the request.
    #
    #   The easier way by far is to pass the <tt>:response</tt> option to
    #   +register_uri+ as a +String+ or an (open for reads) +IO+ object which
    #   will be used as the complete HTTP response, including headers and body.
    #   If the string points to a readable file, this file will be used as the
    #   content for the request.
    #
    #   To obtain a complete response document, you can use the +curl+ command,
    #   like so:
    #
    #     curl -i http://example.com > response_from_example.com
    #
    #   which can then be used in your test environment like so:
    #
    #     FakeWeb.register_uri(:get, "http://example.com", :response => "response_from_example.com")
    #
    #   See the <tt>Net::HTTPResponse</tt>
    #   documentation[http://ruby-doc.org/stdlib/libdoc/net/http/rdoc/classes/Net/HTTPResponse.html]
    #   for more information on creating custom response objects.
    #
    # +options+ may also be an +Array+ containing a list of the above-described
    # +Hash+. In this case, FakeWeb will rotate through each response. You can
    # optionally repeat a response more than once before rotating:
    #
    # <tt>:times</tt>::
    #   The number of times this response will be used before moving on to the
    #   next one. The last response will be repeated indefinitely, regardless of
    #   its <tt>:times</tt> parameter.
    #
    # Two optional arguments are also accepted:
    #
    # <tt>:status</tt>::
    #   Passing <tt>:status</tt> as a two-value array will set the response code
    #   and message. The defaults are <tt>200</tt> and <tt>OK</tt>, respectively.
    #   Example:
    #     FakeWeb.register_uri(:get, "http://example.com", :body => "Go away!", :status => [404, "Not Found"])
    # <tt>:exception</tt>::
    #   The argument passed via <tt>:exception</tt> will be raised when the
    #   specified URL is requested. Any +Exception+ class is valid. Example:
    #     FakeWeb.register_uri(:get, "http://example.com", :exception => Net::HTTPError)
    #
    # If you're using the <tt>:body</tt> response type, you can pass additional
    # options to specify the HTTP headers to be used in the response. Example:
    #
    #   FakeWeb.register_uri(:get, "http://example.com/index.txt", :body => "Hello", :content_type => "text/plain")
    #
    # You can also pass an array of header values to include a header in the
    # response more than once:
    #
    #   FakeWeb.register_uri(:get, "http://example.com", :set_cookie => ["name=value", "example=1"])
    #
    # source://fakeweb//lib/fake_web.rb#150
    def register_uri(*args); end

    # call-seq:
    #   FakeWeb.registered_uri?(method, uri)
    #
    # Returns true if a +method+ request for +uri+ is registered with FakeWeb.
    # Specify a method of <tt>:any</tt> to check against all HTTP methods.
    #
    # @return [Boolean]
    #
    # source://fakeweb//lib/fake_web.rb#183
    def registered_uri?(*args); end

    # call-seq:
    #   FakeWeb.response_for(method, uri)
    #
    # Returns the faked Net::HTTPResponse object associated with +method+ and +uri+.
    #
    # source://fakeweb//lib/fake_web.rb#166
    def response_for(*args, &block); end
  end
end

# This exception is raised if a Net::HTTP request matches more than one of
# the stubs you've registered. To fix the problem, remove a duplicate
# registration or disambiguate any regular expressions by making them more
# specific.
#
# source://fakeweb//lib/fake_web.rb#80
class FakeWeb::MultipleMatchingURIsError < ::StandardError; end

# This exception is raised if you set <tt>FakeWeb.allow_net_connect =
# false</tt> and subsequently try to make a request to a URI you haven't
# stubbed.
#
# source://fakeweb//lib/fake_web.rb#74
class FakeWeb::NetConnectNotAllowedError < ::StandardError; end

# source://fakeweb//lib/fake_web/registry.rb#2
class FakeWeb::Registry
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # @return [Registry] a new instance of Registry
  #
  # source://fakeweb//lib/fake_web/registry.rb#7
  def initialize; end

  # source://fakeweb//lib/fake_web/registry.rb#11
  def clean_registry; end

  # Returns the value of attribute passthrough_uri_map.
  #
  # source://fakeweb//lib/fake_web/registry.rb#5
  def passthrough_uri_map; end

  # Sets the attribute passthrough_uri_map
  #
  # @param value the value to set the attribute passthrough_uri_map to.
  #
  # source://fakeweb//lib/fake_web/registry.rb#5
  def passthrough_uri_map=(_arg0); end

  # @return [Boolean]
  #
  # source://fakeweb//lib/fake_web/registry.rb#49
  def passthrough_uri_matches?(uri); end

  # source://fakeweb//lib/fake_web/registry.rb#41
  def register_passthrough_uri(uri); end

  # source://fakeweb//lib/fake_web/registry.rb#15
  def register_uri(method, uri, options); end

  # @return [Boolean]
  #
  # source://fakeweb//lib/fake_web/registry.rb#21
  def registered_uri?(method, uri); end

  # source://fakeweb//lib/fake_web/registry.rb#45
  def remove_passthrough_uri; end

  # source://fakeweb//lib/fake_web/registry.rb#25
  def response_for(method, uri, &block); end

  # Returns the value of attribute uri_map.
  #
  # source://fakeweb//lib/fake_web/registry.rb#5
  def uri_map; end

  # Sets the attribute uri_map
  #
  # @param value the value to set the attribute uri_map to.
  #
  # source://fakeweb//lib/fake_web/registry.rb#5
  def uri_map=(_arg0); end

  private

  # source://fakeweb//lib/fake_web/registry.rb#105
  def normalize_uri(uri); end

  # source://fakeweb//lib/fake_web/registry.rb#57
  def responders_for(method, uri); end

  # source://fakeweb//lib/fake_web/registry.rb#118
  def sort_query_params(query); end

  # source://fakeweb//lib/fake_web/registry.rb#67
  def uri_map_matches(map, method, uri, type_to_check = T.unsafe(nil)); end

  # source://fakeweb//lib/fake_web/registry.rb#89
  def variations_of_uri_as_strings(uri_object); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://fakeweb//lib/fake_web/responder.rb#2
class FakeWeb::Responder
  # @return [Responder] a new instance of Responder
  #
  # source://fakeweb//lib/fake_web/responder.rb#7
  def initialize(method, uri, options, times); end

  # Returns the value of attribute method.
  #
  # source://fakeweb//lib/fake_web/responder.rb#4
  def method; end

  # Sets the attribute method
  #
  # @param value the value to set the attribute method to.
  #
  # source://fakeweb//lib/fake_web/responder.rb#4
  def method=(_arg0); end

  # Returns the value of attribute options.
  #
  # source://fakeweb//lib/fake_web/responder.rb#4
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://fakeweb//lib/fake_web/responder.rb#4
  def options=(_arg0); end

  # @yield [response]
  #
  # source://fakeweb//lib/fake_web/responder.rb#19
  def response(&block); end

  # Returns the value of attribute times.
  #
  # source://fakeweb//lib/fake_web/responder.rb#4
  def times; end

  # Sets the attribute times
  #
  # @param value the value to set the attribute times to.
  #
  # source://fakeweb//lib/fake_web/responder.rb#4
  def times=(_arg0); end

  # Returns the value of attribute uri.
  #
  # source://fakeweb//lib/fake_web/responder.rb#4
  def uri; end

  # Sets the attribute uri
  #
  # @param value the value to set the attribute uri to.
  #
  # source://fakeweb//lib/fake_web/responder.rb#4
  def uri=(_arg0); end

  private

  # source://fakeweb//lib/fake_web/responder.rb#65
  def baked_response; end

  # source://fakeweb//lib/fake_web/responder.rb#53
  def body; end

  # @return [Boolean]
  #
  # source://fakeweb//lib/fake_web/responder.rb#94
  def has_baked_response?; end

  # source://fakeweb//lib/fake_web/responder.rb#47
  def headers_extracted_from_options; end

  # source://fakeweb//lib/fake_web/responder.rb#109
  def meta_information; end

  # source://fakeweb//lib/fake_web/responder.rb#98
  def optionally_raise(response); end

  # source://fakeweb//lib/fake_web/responder.rb#113
  def print_file_string_options_deprecation_warning; end
end

# source://fakeweb//lib/fake_web/responder.rb#5
FakeWeb::Responder::KNOWN_OPTIONS = T.let(T.unsafe(nil), Array)

# source://fakeweb//lib/fake_web/response.rb#2
module FakeWeb::Response
  # @yield [@body]
  #
  # source://fakeweb//lib/fake_web/response.rb#4
  def read_body(*args, &block); end
end

# source://fakeweb//lib/fake_web/stub_socket.rb#2
class FakeWeb::StubSocket
  # @return [StubSocket] a new instance of StubSocket
  #
  # source://fakeweb//lib/fake_web/stub_socket.rb#4
  def initialize(*args); end

  # @return [Boolean]
  #
  # source://fakeweb//lib/fake_web/stub_socket.rb#7
  def closed?; end

  # source://fakeweb//lib/fake_web/stub_socket.rb#11
  def readuntil(*args); end
end

# source://fakeweb//lib/fake_web/utility.rb#2
module FakeWeb::Utility
  class << self
    # source://fakeweb//lib/fake_web/utility.rb#4
    def decode_userinfo_from_header(header); end

    # source://fakeweb//lib/fake_web/utility.rb#8
    def encode_unsafe_chars_in_userinfo(userinfo); end

    # source://fakeweb//lib/fake_web/utility.rb#48
    def produce_side_effects_of_net_http_request(request, body); end

    # source://fakeweb//lib/fake_web/utility.rb#53
    def puts_warning_for_net_http_around_advice_libs_if_needed; end

    # source://fakeweb//lib/fake_web/utility.rb#71
    def puts_warning_for_net_http_replacement_libs_if_needed; end

    # source://fakeweb//lib/fake_web/utility.rb#66
    def record_loaded_net_http_replacement_libs; end

    # Returns a string with a normalized version of a Net::HTTP request's URI.
    #
    # source://fakeweb//lib/fake_web/utility.rb#22
    def request_uri_as_string(net_http, request); end

    # source://fakeweb//lib/fake_web/utility.rb#13
    def strip_default_port_from_uri(uri); end

    # Wrapper for URI escaping that switches between URI::Parser#escape and
    # URI.escape for 1.9-compatibility
    #
    # source://fakeweb//lib/fake_web/utility.rb#40
    def uri_escape(*args); end
  end
end

# Returns the version string for the copy of FakeWeb you have loaded.
#
# source://fakeweb//lib/fake_web.rb#16
FakeWeb::VERSION = T.let(T.unsafe(nil), String)

# source://fakeweb//lib/fake_web/ext/net_http.rb#7
class Net::BufferedIO
  # source://fakeweb//lib/fake_web/ext/net_http.rb#8
  def initialize(io, debug_output = T.unsafe(nil)); end

  # source://fakeweb//lib/fake_web/ext/net_http.rb#8
  def initialize_with_fakeweb(io, debug_output = T.unsafe(nil)); end
end

# source://fakeweb//lib/fake_web/ext/net_http.rb#29
class Net::HTTP < ::Net::Protocol
  # source://fakeweb//lib/fake_web/ext/net_http.rb#61
  def connect; end

  # source://fakeweb//lib/fake_web/ext/net_http.rb#61
  def connect_with_fakeweb; end

  # source://fakeweb//lib/fake_web/ext/net_http.rb#38
  def request(request, body = T.unsafe(nil), &block); end

  # source://fakeweb//lib/fake_web/ext/net_http.rb#38
  def request_with_fakeweb(request, body = T.unsafe(nil), &block); end

  class << self
    # source://fakeweb//lib/fake_web/ext/net_http.rb#31
    def socket_type; end

    # source://fakeweb//lib/fake_web/ext/net_http.rb#31
    def socket_type_with_fakeweb; end
  end
end
