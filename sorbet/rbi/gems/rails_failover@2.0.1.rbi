# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rails_failover` gem.
# Please instead update this file by running `bin/tapioca gem rails_failover`.

# source://rails_failover//lib/rails_failover/active_record/railtie.rb#3
module RailsFailover; end

# source://rails_failover//lib/rails_failover/active_record/railtie.rb#4
module RailsFailover::ActiveRecord
  class << self
    # source://rails_failover//lib/rails_failover/active_record.rb#13
    def config; end

    # source://rails_failover//lib/rails_failover/active_record.rb#33
    def establish_reading_connection(handler, config, role: T.unsafe(nil)); end

    # source://rails_failover//lib/rails_failover/active_record.rb#21
    def logger; end

    # source://rails_failover//lib/rails_failover/active_record.rb#17
    def logger=(logger); end

    # source://rails_failover//lib/rails_failover/active_record.rb#46
    def on_failover(&block); end

    # source://rails_failover//lib/rails_failover/active_record.rb#50
    def on_failover_callback!(key); end

    # source://rails_failover//lib/rails_failover/active_record.rb#58
    def on_fallback(&block); end

    # source://rails_failover//lib/rails_failover/active_record.rb#62
    def on_fallback_callback!(key); end

    # source://rails_failover//lib/rails_failover/active_record.rb#70
    def reading_role; end

    # source://rails_failover//lib/rails_failover/active_record.rb#42
    def register_force_reading_role_callback(&block); end

    # source://rails_failover//lib/rails_failover/active_record.rb#29
    def verify_primary_frequency_seconds; end

    # source://rails_failover//lib/rails_failover/active_record.rb#25
    def verify_primary_frequency_seconds=(seconds); end

    # source://rails_failover//lib/rails_failover/active_record.rb#74
    def writing_role; end
  end
end

# source://rails_failover//lib/rails_failover/active_record/handler.rb#8
class RailsFailover::ActiveRecord::Handler
  include ::Singleton
  include ::MonitorMixin
  extend ::Singleton::SingletonClassMethods

  # @return [Handler] a new instance of Handler
  #
  # source://rails_failover//lib/rails_failover/active_record/handler.rb#14
  def initialize; end

  # source://rails_failover//lib/rails_failover/active_record/handler.rb#34
  def primaries_down_count; end

  # @return [Boolean]
  #
  # source://rails_failover//lib/rails_failover/active_record/handler.rb#30
  def primary_down?(handler_key); end

  # source://rails_failover//lib/rails_failover/active_record/handler.rb#20
  def verify_primary(handler_key); end

  private

  # source://rails_failover//lib/rails_failover/active_record/handler.rb#83
  def all_primaries_up; end

  # source://rails_failover//lib/rails_failover/active_record/handler.rb#51
  def initiate_fallback_to_primary; end

  # source://rails_failover//lib/rails_failover/active_record/handler.rb#116
  def logger; end

  # source://rails_failover//lib/rails_failover/active_record/handler.rb#40
  def loop_until_all_up; end

  # source://rails_failover//lib/rails_failover/active_record/handler.rb#101
  def primaries_down; end

  # source://rails_failover//lib/rails_failover/active_record/handler.rb#87
  def primary_down(handler_key); end

  # source://rails_failover//lib/rails_failover/active_record/handler.rb#92
  def primary_up(handler_key); end

  # source://rails_failover//lib/rails_failover/active_record/handler.rb#97
  def spec_name; end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://rails_failover//lib/rails_failover/active_record/handler.rb#12
RailsFailover::ActiveRecord::Handler::VERIFY_FREQUENCY_BUFFER_PERCENT = T.let(T.unsafe(nil), Integer)

# source://rails_failover//lib/rails_failover/active_record/middleware.rb#5
class RailsFailover::ActiveRecord::Interceptor
  class << self
    # source://rails_failover//lib/rails_failover/active_record/middleware.rb#6
    def adapter_errors; end

    # source://rails_failover//lib/rails_failover/active_record/middleware.rb#17
    def handle(request, exception); end

    # source://rails_failover//lib/rails_failover/active_record/middleware.rb#29
    def resolve_cause(exception); end

    # source://rails_failover//lib/rails_failover/active_record/middleware.rb#21
    def verify_primary(exception, writing_role); end
  end
end

# source://rails_failover//lib/rails_failover/active_record/middleware.rb#34
class RailsFailover::ActiveRecord::Middleware
  # @return [Middleware] a new instance of Middleware
  #
  # source://rails_failover//lib/rails_failover/active_record/middleware.rb#42
  def initialize(app); end

  # source://rails_failover//lib/rails_failover/active_record/middleware.rb#46
  def call(env); end

  private

  # source://rails_failover//lib/rails_failover/active_record/middleware.rb#76
  def ensure_reading_connection_established!(writing_role:, reading_role:); end

  # source://rails_failover//lib/rails_failover/active_record/middleware.rb#101
  def resolve_reading_role(current_role, is_writing_role); end

  # source://rails_failover//lib/rails_failover/active_record/middleware.rb#90
  def resolve_writing_role(current_role, is_writing_role); end

  class << self
    # Returns the value of attribute force_reading_role_callback.
    #
    # source://rails_failover//lib/rails_failover/active_record/middleware.rb#36
    def force_reading_role_callback; end

    # Sets the attribute force_reading_role_callback
    #
    # @param value the value to set the attribute force_reading_role_callback to.
    #
    # source://rails_failover//lib/rails_failover/active_record/middleware.rb#36
    def force_reading_role_callback=(_arg0); end
  end
end

# source://rails_failover//lib/rails_failover/active_record/middleware.rb#39
RailsFailover::ActiveRecord::Middleware::CURRENT_ROLE_HEADER = T.let(T.unsafe(nil), String)

# source://rails_failover//lib/rails_failover/active_record/middleware.rb#40
RailsFailover::ActiveRecord::Middleware::WRITING_ROLE_HEADER = T.let(T.unsafe(nil), String)

# source://rails_failover//lib/rails_failover/active_record/railtie.rb#5
class RailsFailover::ActiveRecord::Railtie < ::Rails::Railtie
  # @return [Boolean]
  #
  # source://rails_failover//lib/rails_failover/active_record/railtie.rb#35
  def skip_middleware?(config); end
end

# source://rails_failover//lib/rails_failover.rb#6
class RailsFailover::Error < ::StandardError; end

# source://rails_failover//lib/rails_failover/redis/handler.rb#8
class RailsFailover::Redis
  class << self
    # For testing
    #
    # source://rails_failover//lib/rails_failover/redis.rb#64
    def clear_callbacks; end

    # source://rails_failover//lib/rails_failover/redis.rb#23
    def logger; end

    # source://rails_failover//lib/rails_failover/redis.rb#19
    def logger=(logger); end

    # source://rails_failover//lib/rails_failover/redis.rb#39
    def on_failover(&block); end

    # source://rails_failover//lib/rails_failover/redis.rb#43
    def on_failover_callback!(key); end

    # source://rails_failover//lib/rails_failover/redis.rb#51
    def on_fallback(&block); end

    # source://rails_failover//lib/rails_failover/redis.rb#55
    def on_fallback_callback!(key); end

    # source://rails_failover//lib/rails_failover/redis.rb#35
    def verify_primary_frequency_seconds; end

    # source://rails_failover//lib/rails_failover/redis.rb#31
    def verify_primary_frequency_seconds=(seconds); end
  end
end

# source://rails_failover//lib/rails_failover/redis/connector.rb#7
class RailsFailover::Redis::Connector < ::Redis::Client::Connector
  # @return [Connector] a new instance of Connector
  #
  # source://rails_failover//lib/rails_failover/redis/connector.rb#8
  def initialize(options); end

  # source://rails_failover//lib/rails_failover/redis/connector.rb#52
  def check(client); end

  # source://rails_failover//lib/rails_failover/redis/connector.rb#60
  def on_disconnect(client); end

  # source://rails_failover//lib/rails_failover/redis/connector.rb#48
  def resolve; end

  private

  # source://rails_failover//lib/rails_failover/redis/connector.rb#66
  def replica_options(options); end
end

# source://rails_failover//lib/rails_failover/redis/handler.rb#9
class RailsFailover::Redis::Handler
  include ::Singleton
  include ::MonitorMixin
  extend ::Singleton::SingletonClassMethods

  # @return [Handler] a new instance of Handler
  #
  # source://rails_failover//lib/rails_failover/redis/handler.rb#19
  def initialize; end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#41
  def deregister_client(client); end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#50
  def primaries_down_count; end

  # @return [Boolean]
  #
  # source://rails_failover//lib/rails_failover/redis/handler.rb#46
  def primary_down?(options); end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#36
  def register_client(client); end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#26
  def verify_primary(options); end

  private

  # source://rails_failover//lib/rails_failover/redis/handler.rb#101
  def all_primaries_up; end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#134
  def clients; end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#130
  def clients_for_id(id); end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#151
  def disconnect_clients(options, role); end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#145
  def ensure_primary_clients_disconnected; end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#198
  def logger; end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#56
  def loop_until_all_up; end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#115
  def primaries_down; end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#110
  def primary_down(options); end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#105
  def primary_up(options); end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#210
  def redis_mon_exit(redis); end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#202
  def redis_mon_try_enter(redis); end

  # Calling .disconnect can cause a running subscribe() to block forever
  # Therefore try to acquire the lock
  #
  # source://rails_failover//lib/rails_failover/redis/handler.rb#172
  def soft_disconnect(redis, client, role); end

  # source://rails_failover//lib/rails_failover/redis/handler.rb#68
  def try_fallback_to_primary; end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://rails_failover//lib/rails_failover/redis/handler.rb#14
RailsFailover::Redis::Handler::PRIMARY_LOADED_STATUS = T.let(T.unsafe(nil), String)

# source://rails_failover//lib/rails_failover/redis/handler.rb#13
RailsFailover::Redis::Handler::PRIMARY_ROLE_STATUS = T.let(T.unsafe(nil), String)

# source://rails_failover//lib/rails_failover/redis/handler.rb#17
RailsFailover::Redis::Handler::SOFT_DISCONNECT_POLL_SECONDS = T.let(T.unsafe(nil), Float)

# source://rails_failover//lib/rails_failover/redis/handler.rb#16
RailsFailover::Redis::Handler::SOFT_DISCONNECT_TIMEOUT_SECONDS = T.let(T.unsafe(nil), Integer)

# source://rails_failover//lib/rails_failover/redis/handler.rb#15
RailsFailover::Redis::Handler::VERIFY_FREQUENCY_BUFFER_PERCENT = T.let(T.unsafe(nil), Integer)

# source://rails_failover//lib/rails_failover/redis.rb#16
RailsFailover::Redis::PRIMARY = T.let(T.unsafe(nil), Symbol)

# source://rails_failover//lib/rails_failover/redis.rb#17
RailsFailover::Redis::REPLICA = T.let(T.unsafe(nil), Symbol)

# source://rails_failover//lib/rails_failover/version.rb#4
RailsFailover::VERSION = T.let(T.unsafe(nil), String)

# See https://github.com/redis/redis-rb/pull/908
#
# source://rails_failover//lib/redis/patches/client.rb#6
class Redis::Client
  # source://redis/4.8.1/lib/redis/client.rb#91
  def initialize(options = T.unsafe(nil)); end

  # source://redis/4.8.1/lib/redis/client.rb#160
  def call(command); end

  # source://redis/4.8.1/lib/redis/client.rb#171
  def call_loop(command, timeout = T.unsafe(nil)); end

  # source://redis/4.8.1/lib/redis/client.rb#195
  def call_pipeline(pipeline); end

  # source://redis/4.8.1/lib/redis/client.rb#214
  def call_pipelined(pipeline); end

  # source://redis/4.8.1/lib/redis/client.rb#254
  def call_with_timeout(command, extra_timeout, &blk); end

  # source://redis/4.8.1/lib/redis/client.rb#263
  def call_without_timeout(command, &blk); end

  # source://redis/4.8.1/lib/redis/client.rb#288
  def close; end

  # source://redis/4.8.1/lib/redis/client.rb#35
  def command_map; end

  # source://redis/4.8.1/lib/redis/client.rb#110
  def connect; end

  # source://redis/4.8.1/lib/redis/client.rb#57
  def connect_timeout; end

  # source://redis/4.8.1/lib/redis/client.rb#284
  def connected?; end

  # source://redis/4.8.1/lib/redis/client.rb#35
  def connection; end

  # source://redis/4.8.1/lib/redis/client.rb#73
  def db; end

  # source://redis/4.8.1/lib/redis/client.rb#77
  def db=(db); end

  # source://rails_failover//lib/redis/patches/client.rb#7
  def disconnect; end

  # source://redis/4.8.1/lib/redis/client.rb#81
  def driver; end

  # source://redis/4.8.1/lib/redis/client.rb#41
  def host; end

  # source://redis/4.8.1/lib/redis/client.rb#152
  def id; end

  # source://redis/4.8.1/lib/redis/client.rb#85
  def inherit_socket?; end

  # source://redis/4.8.1/lib/redis/client.rb#298
  def io; end

  # source://redis/4.8.1/lib/redis/client.rb#156
  def location; end

  # source://redis/4.8.1/lib/redis/client.rb#89
  def logger; end

  # source://redis/4.8.1/lib/redis/client.rb#89
  def logger=(_arg0); end

  # source://redis/4.8.1/lib/redis/client.rb#35
  def options; end

  # source://redis/4.8.1/lib/redis/client.rb#69
  def password; end

  # source://redis/4.8.1/lib/redis/client.rb#49
  def path; end

  # source://redis/4.8.1/lib/redis/client.rb#45
  def port; end

  # source://redis/4.8.1/lib/redis/client.rb#267
  def process(commands); end

  # source://redis/4.8.1/lib/redis/client.rb#309
  def read; end

  # source://redis/4.8.1/lib/redis/client.rb#53
  def read_timeout; end

  # source://redis/4.8.1/lib/redis/client.rb#293
  def reconnect; end

  # source://redis/4.8.1/lib/redis/client.rb#37
  def scheme; end

  # source://redis/4.8.1/lib/redis/client.rb#61
  def timeout; end

  # source://redis/4.8.1/lib/redis/client.rb#65
  def username; end

  # source://redis/4.8.1/lib/redis/client.rb#342
  def with_reconnect(val = T.unsafe(nil)); end

  # source://redis/4.8.1/lib/redis/client.rb#324
  def with_socket_timeout(timeout); end

  # source://redis/4.8.1/lib/redis/client.rb#349
  def without_reconnect(&blk); end

  # source://redis/4.8.1/lib/redis/client.rb#338
  def without_socket_timeout(&blk); end

  # source://redis/4.8.1/lib/redis/client.rb#317
  def write(command); end

  protected

  # source://redis/4.8.1/lib/redis/client.rb#529
  def _parse_driver(driver); end

  # source://redis/4.8.1/lib/redis/client.rb#430
  def _parse_options(options); end

  # source://redis/4.8.1/lib/redis/client.rb#401
  def ensure_connected; end

  # source://redis/4.8.1/lib/redis/client.rb#379
  def establish_connection; end

  # source://redis/4.8.1/lib/redis/client.rb#355
  def logging(commands); end
end

# source://rails_failover//lib/redis/patches/client.rb#16
class Redis::Client::Connector
  # source://redis/4.8.1/lib/redis/client.rb#550
  def initialize(options); end

  # source://redis/4.8.1/lib/redis/client.rb#558
  def check(client); end

  # source://rails_failover//lib/redis/patches/client.rb#17
  def on_disconnect(client); end

  # source://redis/4.8.1/lib/redis/client.rb#554
  def resolve; end
end
