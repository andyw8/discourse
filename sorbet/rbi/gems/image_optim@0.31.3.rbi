# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `image_optim` gem.
# Please instead update this file by running `bin/tapioca gem image_optim`.

# Main interface
#
# source://image_optim//lib/image_optim/bin_resolver/error.rb#3
class ImageOptim
  # Initialize workers, specify options using worker underscored name:
  #
  # pass false to disable worker
  #
  #     ImageOptim.new(:pngcrush => false)
  #
  # or hash with options to worker
  #
  #     ImageOptim.new(:advpng => {:level => 3}, :optipng => {:level => 2})
  #
  # use :threads to set number of parallel optimizers to run (passing true or
  # nil determines number of processors, false disables parallel processing)
  #
  #     ImageOptim.new(:threads => 8)
  #
  # use :nice to specify optimizers nice level (true or nil makes it 10, false
  # makes it 0)
  #
  #     ImageOptim.new(:nice => 20)
  #
  # @return [ImageOptim] a new instance of ImageOptim
  #
  # source://image_optim//lib/image_optim.rb#73
  def initialize(options = T.unsafe(nil)); end

  # Allow lossy workers and optimizations
  #
  # source://image_optim//lib/image_optim.rb#43
  def allow_lossy; end

  # Cache directory
  #
  # source://image_optim//lib/image_optim.rb#46
  def cache_dir; end

  # Cache worker digests
  #
  # source://image_optim//lib/image_optim.rb#49
  def cache_worker_digests; end

  # Join resolve_dir, default path and vendor path for PATH environment variable
  #
  # source://image_optim//lib/image_optim.rb#234
  def env_path; end

  # Nice level
  #
  # source://image_optim//lib/image_optim.rb#28
  def nice; end

  # Are there workers for file at path?
  #
  # @return [Boolean]
  #
  # source://image_optim//lib/image_optim.rb#223
  def optimizable?(path); end

  # Optimize one file, return new path as OptimizedPath or nil if
  # optimization failed
  #
  # source://image_optim//lib/image_optim.rb#114
  def optimize_image(original); end

  # Optimize one file in place, return original as OptimizedPath or nil if
  # optimization failed
  #
  # source://image_optim//lib/image_optim.rb#141
  def optimize_image!(original); end

  # Optimize image data, return new data or nil if optimization failed
  #
  # source://image_optim//lib/image_optim.rb#150
  def optimize_image_data(original_data); end

  # Optimize multiple images
  # if block given yields path and result for each image and returns array of
  # yield results
  # else return array of path and result pairs
  #
  # source://image_optim//lib/image_optim.rb#169
  def optimize_images(paths, &block); end

  # Optimize multiple images in place
  # if block given yields path and result for each image and returns array of
  # yield results
  # else return array of path and result pairs
  #
  # source://image_optim//lib/image_optim.rb#177
  def optimize_images!(paths, &block); end

  # Optimize multiple image datas
  # if block given yields original and result for each image data and returns
  # array of yield results
  # else return array of path and result pairs
  #
  # source://image_optim//lib/image_optim.rb#185
  def optimize_images_data(datas, &block); end

  # Use image_optim_pack
  #
  # source://image_optim//lib/image_optim.rb#37
  def pack; end

  # Check existance of binary, create symlink if ENV contains path for key
  # XXX_BIN where XXX is upper case bin name
  #
  # source://image_optim//lib/image_optim.rb#229
  def resolve_bin!(bin); end

  # Skip workers with missing or problematic binaries
  #
  # source://image_optim//lib/image_optim.rb#40
  def skip_missing_workers; end

  # Number of threads to run with
  #
  # source://image_optim//lib/image_optim.rb#31
  def threads; end

  # Timeout in seconds for each image
  #
  # source://image_optim//lib/image_optim.rb#52
  def timeout; end

  # Verbose output?
  #
  # source://image_optim//lib/image_optim.rb#34
  def verbose; end

  # Get workers for image
  #
  # source://image_optim//lib/image_optim.rb#108
  def workers_for_image(path); end

  private

  # Apply threading if threading is allowed
  #
  # source://image_optim//lib/image_optim.rb#269
  def apply_threading(enum); end

  # source://image_optim//lib/image_optim.rb#240
  def log_workers_by_format; end

  # Run method for each item in list
  # if block given yields item and result for item and returns array of yield
  # results
  # else return array of item and result pairs
  #
  # source://image_optim//lib/image_optim.rb#257
  def run_method_for(list, method_name, &block); end

  class << self
    # Full version of image_optim
    #
    # source://image_optim//lib/image_optim.rb#211
    def full_version; end

    # Optimization methods with default options
    #
    # source://image_optim//lib/image_optim.rb#191
    def method_missing(method, *args, &block); end

    # @return [Boolean]
    #
    # source://image_optim//lib/image_optim.rb#199
    def respond_to_missing?(method, include_private = T.unsafe(nil)); end

    # Version of image_optim gem spec loaded
    #
    # source://image_optim//lib/image_optim.rb#204
    def version; end

    private

    # @return [Boolean]
    #
    # source://image_optim//lib/image_optim.rb#217
    def optimize_image_method?(method); end
  end
end

# Handles resolving binaries and checking versions
#
# If there is an environment variable XXX_BIN when resolving xxx, then a
# symlink to binary will be created in a temporary directory which will be
# added to PATH
#
# source://image_optim//lib/image_optim/bin_resolver/error.rb#4
class ImageOptim::BinResolver
  # @return [BinResolver] a new instance of BinResolver
  #
  # source://image_optim//lib/image_optim/bin_resolver.rb#23
  def initialize(image_optim); end

  # Directory for symlinks to bins if XXX_BIN was used
  #
  # source://image_optim//lib/image_optim/bin_resolver.rb#18
  def dir; end

  # Prepand `dir` and append `VENDOR_PATH` to `PATH` from environment
  #
  # source://image_optim//lib/image_optim/bin_resolver.rb#60
  def env_path; end

  # Path to pack from image_optim_pack if used
  #
  # source://image_optim//lib/image_optim/bin_resolver.rb#21
  def pack_path; end

  # Binary resolving: create symlink if there is XXX_BIN environment variable,
  # build Bin with full path, check binary version
  # Return Bin instance
  #
  # source://image_optim//lib/image_optim/bin_resolver.rb#33
  def resolve!(name); end

  private

  # Return full path to bin or null
  # based on http://stackoverflow.com/a/5471032/96823
  #
  # source://image_optim//lib/image_optim/bin_resolver.rb#135
  def full_path(name); end

  # source://image_optim//lib/image_optim/bin_resolver.rb#84
  def init_pack; end

  # Double-checked locking
  #
  # source://image_optim//lib/image_optim/bin_resolver.rb#100
  def resolving(name); end

  # Check path in XXX_BIN to exist, be a file and be executable and symlink to
  # dir as name
  #
  # source://image_optim//lib/image_optim/bin_resolver.rb#110
  def symlink_custom_bin!(name); end

  class << self
    # Collect resolving errors when running block over items of enumerable
    #
    # source://image_optim//lib/image_optim/bin_resolver.rb#70
    def collect_errors(enumerable); end
  end
end

# Holds bin name and path, gets version
#
# source://image_optim//lib/image_optim/bin_resolver/bin.rb#15
class ImageOptim::BinResolver::Bin
  # @return [Bin] a new instance of Bin
  #
  # source://image_optim//lib/image_optim/bin_resolver/bin.rb#22
  def initialize(name, path); end

  # Run check_fail!, otherwise warn if version is known to misbehave
  #
  # source://image_optim//lib/image_optim/bin_resolver/bin.rb#85
  def check!; end

  # Fail if version will not work properly
  #
  # source://image_optim//lib/image_optim/bin_resolver/bin.rb#70
  def check_fail!; end

  # source://image_optim//lib/image_optim/bin_resolver/bin.rb#28
  def digest; end

  # Returns the value of attribute name.
  #
  # source://image_optim//lib/image_optim/bin_resolver/bin.rb#20
  def name; end

  # Returns the value of attribute path.
  #
  # source://image_optim//lib/image_optim/bin_resolver/bin.rb#20
  def path; end

  # source://image_optim//lib/image_optim/bin_resolver/bin.rb#34
  def to_s; end

  # Returns the value of attribute version.
  #
  # source://image_optim//lib/image_optim/bin_resolver/bin.rb#20
  def version; end

  private

  # source://image_optim//lib/image_optim/bin_resolver/bin.rb#134
  def capture(cmd); end

  # Wrap version_string with SimpleVersion
  #
  # source://image_optim//lib/image_optim/bin_resolver/bin.rb#102
  def detect_version; end

  # source://image_optim//lib/image_optim/bin_resolver/bin.rb#138
  def escaped_path; end

  # Getting version of bin, will fail for an unknown name
  #
  # source://image_optim//lib/image_optim/bin_resolver/bin.rb#108
  def version_string; end
end

# source://image_optim//lib/image_optim/bin_resolver/bin.rb#18
class ImageOptim::BinResolver::Bin::BadVersion < ::ImageOptim::BinResolver::Error; end

# source://image_optim//lib/image_optim/bin_resolver/bin.rb#40
ImageOptim::BinResolver::Bin::FAIL_CHECKS = T.let(T.unsafe(nil), Hash)

# source://image_optim//lib/image_optim/bin_resolver/bin.rb#16
class ImageOptim::BinResolver::Bin::UnknownVersion < ::ImageOptim::BinResolver::Error; end

# source://image_optim//lib/image_optim/bin_resolver/bin.rb#50
ImageOptim::BinResolver::Bin::WARN_CHECKS = T.let(T.unsafe(nil), Hash)

# source://image_optim//lib/image_optim/bin_resolver.rb#15
class ImageOptim::BinResolver::BinNotFound < ::ImageOptim::BinResolver::Error; end

# Allows to externalize conditions for an instance of Comparable to use in
# case statemens
#
#     is = ComparableCondition.is
#     case rand(100)
#     when is < 10 then # ...
#     when is.between?(13, 23) then # ...
#     when is >= 90 then # ...
#     end
#
# source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#14
class ImageOptim::BinResolver::ComparableCondition
  # @return [ComparableCondition] a new instance of ComparableCondition
  #
  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#30
  def initialize(method, *args); end

  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#43
  def ===(other); end

  # Returns the value of attribute args.
  #
  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#28
  def args; end

  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#43
  def match(other); end

  # Returns the value of attribute method.
  #
  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#28
  def method; end

  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#48
  def to_s; end

  private

  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#58
  def argument_error!(message); end

  class << self
    # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#24
    def is; end
  end
end

# Helper class for creating conditions using ComparableCondition.is
#
# source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#16
class ImageOptim::BinResolver::ComparableCondition::Builder
  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#18
  def <(*args); end

  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#18
  def <=(*args); end

  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#18
  def ==(*args); end

  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#18
  def >(*args); end

  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#18
  def >=(*args); end

  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#18
  def between?(*args); end

  # source://image_optim//lib/image_optim/bin_resolver/comparable_condition.rb#18
  def clamp(*args); end
end

# Base error during bin resolving
#
# source://image_optim//lib/image_optim/bin_resolver/error.rb#6
class ImageOptim::BinResolver::Error < ::StandardError; end

# Allows comparision of simple versions, only numbers separated by dots are
# taken into account
#
# source://image_optim//lib/image_optim/bin_resolver/simple_version.rb#7
class ImageOptim::BinResolver::SimpleVersion
  include ::Comparable

  # Initialize with a string or an object convertible to string
  #
  #    SimpleVersion.new('2.0.1') <=> SimpleVersion.new(2)
  #
  # @return [SimpleVersion] a new instance of SimpleVersion
  #
  # source://image_optim//lib/image_optim/bin_resolver/simple_version.rb#16
  def initialize(str); end

  # Compare version parts of self with other
  #
  # source://image_optim//lib/image_optim/bin_resolver/simple_version.rb#27
  def <=>(other); end

  # Numbers extracted from version string
  #
  # source://image_optim//lib/image_optim/bin_resolver/simple_version.rb#11
  def parts; end

  # Returns original version string
  #
  # source://image_optim//lib/image_optim/bin_resolver/simple_version.rb#22
  def to_s; end
end

# Path to vendor at root of image_optim
#
# source://image_optim//lib/image_optim/bin_resolver.rb#57
ImageOptim::BinResolver::VENDOR_PATH = T.let(T.unsafe(nil), String)

# Handles image cache
#
# source://image_optim//lib/image_optim/cache.rb#9
class ImageOptim::Cache
  # @return [Cache] a new instance of Cache
  #
  # source://image_optim//lib/image_optim/cache.rb#10
  def initialize(image_optim, workers_by_format); end

  # source://image_optim//lib/image_optim/cache.rb#31
  def fetch(original); end

  private

  # source://image_optim//lib/image_optim/cache.rb#68
  def bins_by_format(format); end

  # source://image_optim//lib/image_optim/cache.rb#72
  def digest(path, format); end

  # source://image_optim//lib/image_optim/cache.rb#64
  def options_by_format(format); end
end

# ImageOptiom::Path with a non self destructing #replace method
#
# source://image_optim//lib/image_optim/cache_path.rb#7
class ImageOptim::CachePath < ::ImageOptim::Path
  # Atomic replace dst with self
  #
  # source://image_optim//lib/image_optim/cache_path.rb#9
  def replace(dst); end

  private

  # source://image_optim//lib/image_optim/cache_path.rb#27
  def replace_using_tmp_file(dst, tmpdir); end
end

# Helper for running commands
#
# source://image_optim//lib/image_optim/cmd.rb#8
module ImageOptim::Cmd
  class << self
    # Run using backtick
    # Return captured output
    # Will raise SignalException if process was interrupted
    #
    # source://image_optim//lib/image_optim/cmd.rb#43
    def capture(cmd); end

    # Run using `system`
    # Return success status
    # Will raise SignalException if process was interrupted
    #
    # source://image_optim//lib/image_optim/cmd.rb#13
    def run(*args); end

    private

    # source://image_optim//lib/image_optim/cmd.rb#53
    def check_status!(status = T.unsafe(nil)); end

    # source://image_optim//lib/image_optim/cmd.rb#68
    def cleanup(pid, waiter); end

    # source://image_optim//lib/image_optim/cmd.rb#83
    def kill(signal, pid); end
  end
end

# Read, merge and parse configuration
#
# source://image_optim//lib/image_optim/config.rb#13
class ImageOptim::Config
  include ::ImageOptim::OptionHelpers

  # Merge config from files with passed options
  # Config files are checked at `GLOBAL_PATH` and `LOCAL_PATH` unless
  # overriden using `:config_paths`
  #
  # @return [Config] a new instance of Config
  #
  # source://image_optim//lib/image_optim/config.rb#59
  def initialize(options); end

  # Allow lossy workers and optimizations, converted to boolean
  #
  # source://image_optim//lib/image_optim/config.rb#167
  def allow_lossy; end

  # Fail unless all options were marked as used (directly or indirectly
  # accessed using `get!`)
  #
  # source://image_optim//lib/image_optim/config.rb#87
  def assert_no_unused_options!; end

  # source://image_optim//lib/image_optim/config.rb#171
  def cache_dir; end

  # source://image_optim//lib/image_optim/config.rb#176
  def cache_worker_digests; end

  # Options for worker class by its `bin_sym`:
  # * `Hash` passed as is
  # * `{}` for `true` or `nil`
  # * `false` for `false`
  # * otherwise fail with `ConfigurationError`
  #
  # source://image_optim//lib/image_optim/config.rb#185
  def for_worker(klass); end

  # Gets value for key converted to symbol and mark option as used
  #
  # source://image_optim//lib/image_optim/config.rb#73
  def get!(key); end

  # Check if key is present
  #
  # @return [Boolean]
  #
  # source://image_optim//lib/image_optim/config.rb#80
  def key?(key); end

  # Nice level:
  # * `10` by default and for `nil` or `true`
  # * `0` for `false`
  # * otherwise convert to integer
  #
  # source://image_optim//lib/image_optim/config.rb#98
  def nice; end

  # Using image_optim_pack:
  # * `false` to disable
  # * `nil` to use if available
  # * everything else to require
  #
  # source://image_optim//lib/image_optim/config.rb#145
  def pack; end

  # Skip missing workers, converted to boolean
  #
  # source://image_optim//lib/image_optim/config.rb#158
  def skip_missing_workers; end

  # Number of parallel threads:
  # * `processor_count` by default and for `nil` or `true`
  # * `1` for `false`
  # * otherwise convert to integer
  #
  # source://image_optim//lib/image_optim/config.rb#115
  def threads; end

  # Timeout in seconds for each image:
  # * not set by default and for `nil`
  # * otherwise converted to float
  #
  # source://image_optim//lib/image_optim/config.rb#131
  def timeout; end

  # yaml dump without document beginning prefix `---`
  #
  # source://image_optim//lib/image_optim/config.rb#202
  def to_s; end

  # Verbose mode, converted to boolean
  #
  # source://image_optim//lib/image_optim/config.rb#137
  def verbose; end

  private

  # http://stackoverflow.com/a/6420817
  #
  # source://image_optim//lib/image_optim/config.rb#209
  def processor_count; end

  class << self
    # source://image_optim//lib/image_optim/config.rb#47
    def load_yaml_file(path); end

    # Read options at path: expand path (warn on failure), return {} if file
    # does not exist or is empty, read yaml, check if it is a Hash, deep
    # symbolise keys
    #
    # source://image_optim//lib/image_optim/config.rb#27
    def read_options(path); end
  end
end

# Global config path at `$XDG_CONFIG_HOME/image_optim.yml` (by default
# `~/.config/image_optim.yml`)
#
# source://image_optim//lib/image_optim/config.rb#18
ImageOptim::Config::GLOBAL_PATH = T.let(T.unsafe(nil), String)

# Local config path at `./.image_optim.yml`
#
# source://image_optim//lib/image_optim/config.rb#21
ImageOptim::Config::LOCAL_PATH = T.let(T.unsafe(nil), String)

# source://image_optim//lib/image_optim/configuration_error.rb#4
class ImageOptim::ConfigurationError < ::StandardError; end

# Use Process.clock_gettime if available to get time more fitting to calculate elapsed time
#
# source://image_optim//lib/image_optim/elapsed_time.rb#5
module ImageOptim::ElapsedTime
  private

  # source://image_optim//lib/image_optim/elapsed_time.rb#18
  def now; end

  class << self
    # source://image_optim//lib/image_optim/elapsed_time.rb#18
    def now; end
  end
end

# source://image_optim//lib/image_optim/elapsed_time.rb#14
ImageOptim::ElapsedTime::CLOCK_ID = T.let(T.unsafe(nil), Integer)

# source://image_optim//lib/image_optim/elapsed_time.rb#6
ImageOptim::ElapsedTime::CLOCK_NAME = T.let(T.unsafe(nil), String)

# source://image_optim//lib/image_optim/errors.rb#4
class ImageOptim::Error < ::StandardError; end

# source://image_optim//lib/image_optim/errors.rb#6
module ImageOptim::Errors; end

# source://image_optim//lib/image_optim/errors.rb#7
class ImageOptim::Errors::TimeoutExceeded < ::ImageOptim::Error; end

# Handles processing of original to result using upto two temp files
#
# source://image_optim//lib/image_optim/handler.rb#7
class ImageOptim::Handler
  # original must respond to temp_path
  #
  # @return [Handler] a new instance of Handler
  #
  # source://image_optim//lib/image_optim/handler.rb#12
  def initialize(original); end

  # Remove extra temp files
  #
  # source://image_optim//lib/image_optim/handler.rb#54
  def cleanup; end

  # Yields two paths, one to latest successful result or original, second to
  # temp path
  #
  # source://image_optim//lib/image_optim/handler.rb#39
  def process; end

  # Holds latest successful result
  #
  # source://image_optim//lib/image_optim/handler.rb#9
  def result; end

  class << self
    # with no associated block, works as new. Otherwise creates instance and
    # passes it to block, runs cleanup and returns result of handler
    #
    # source://image_optim//lib/image_optim/handler.rb#23
    def for(original); end
  end
end

# Helper methods to manipulate Hash, mainly used in config
#
# source://image_optim//lib/image_optim/hash_helpers.rb#5
module ImageOptim::HashHelpers
  class << self
    # Returns a new hash with recursive merge of all keys
    #
    # source://image_optim//lib/image_optim/hash_helpers.rb#20
    def deep_merge(hash_a, hash_b); end

    # Returns a new hash with all keys of root and nested hashes converted to
    # strings
    #
    # source://image_optim//lib/image_optim/hash_helpers.rb#9
    def deep_stringify_keys(hash); end

    # Returns a new hash with all keys of root and nested hashes converted to
    # symbols
    #
    # source://image_optim//lib/image_optim/hash_helpers.rb#15
    def deep_symbolise_keys(hash); end

    private

    # Returns a new hash with all keys of root and nested hashes converted by
    # provided block
    #
    # source://image_optim//lib/image_optim/hash_helpers.rb#34
    def deep_transform_keys(hash, &block); end
  end
end

# Getting format of image at path or as data
#
# source://image_optim//lib/image_optim/image_meta.rb#7
module ImageOptim::ImageMeta
  class << self
    # source://image_optim//lib/image_optim/image_meta.rb#15
    def format_for_data(data); end

    # source://image_optim//lib/image_optim/image_meta.rb#8
    def format_for_path(path); end
  end
end

# Denote range of non negative integers for worker option
#
# source://image_optim//lib/image_optim/non_negative_integer_range.rb#5
class ImageOptim::NonNegativeIntegerRange
  class << self
    # Add handling of range of non negative integers in OptionParser instance
    #
    # source://image_optim//lib/image_optim/non_negative_integer_range.rb#7
    def add_to_option_parser(option_parser); end
  end
end

# Holds optimized image with reference to original and its size
#
# source://image_optim//lib/image_optim/optimized_path.rb#9
class ImageOptim::OptimizedPath
  # @return [OptimizedPath] a new instance of OptimizedPath
  #
  # source://image_optim//lib/image_optim/optimized_path.rb#10
  def initialize(path, original_or_size = T.unsafe(nil)); end

  # Original path, use original_size to get its size as original can be
  # overwritten
  #
  # source://image_optim//lib/image_optim/optimized_path.rb#24
  def original; end

  # Stored size of original
  #
  # source://image_optim//lib/image_optim/optimized_path.rb#27
  def original_size; end
end

# Hold information about an option
#
# source://image_optim//lib/image_optim/option_definition.rb#5
class ImageOptim::OptionDefinition
  # @return [OptionDefinition] a new instance of OptionDefinition
  #
  # source://image_optim//lib/image_optim/option_definition.rb#8
  def initialize(name, default, type_or_description, description = T.unsafe(nil), &proc); end

  # Returns the value of attribute default.
  #
  # source://image_optim//lib/image_optim/option_definition.rb#6
  def default; end

  # Describe default value, returns string as is otherwise surrounds
  # inspected value with backticks
  #
  # source://image_optim//lib/image_optim/option_definition.rb#36
  def default_description; end

  # Returns the value of attribute description.
  #
  # source://image_optim//lib/image_optim/option_definition.rb#6
  def description; end

  # Returns the value of attribute name.
  #
  # source://image_optim//lib/image_optim/option_definition.rb#6
  def name; end

  # Returns the value of attribute proc.
  #
  # source://image_optim//lib/image_optim/option_definition.rb#6
  def proc; end

  # Returns the value of attribute type.
  #
  # source://image_optim//lib/image_optim/option_definition.rb#6
  def type; end

  # Get value for worker from options
  #
  # source://image_optim//lib/image_optim/option_definition.rb#21
  def value(worker, options); end
end

# Helper methods for options
#
# source://image_optim//lib/image_optim/option_helpers.rb#5
module ImageOptim::OptionHelpers
  class << self
    # Ensure number is in range
    #
    # source://image_optim//lib/image_optim/option_helpers.rb#7
    def limit_with_range(number, range); end
  end
end

# FSPath with additional helpful methods
#
# source://image_optim//lib/image_optim/path.rb#8
class ImageOptim::Path < ::FSPath
  # Copy file to dst, optionally preserving attributes
  #
  # See FileUtils.copy_file
  #
  # source://image_optim//lib/image_optim/path.rb#24
  def copy(dst, preserve = T.unsafe(nil)); end

  # Copy metadata: uid, gid, mode, optionally atime and mtime
  #
  # Adapted from FileUtils::Entry_#copy_metadata by Minero Aoki
  #
  # source://image_optim//lib/image_optim/path.rb#39
  def copy_metadata(dst, time = T.unsafe(nil)); end

  # Get format using ImageSize
  #
  # source://image_optim//lib/image_optim/path.rb#67
  def image_format; end

  # Move file to dst: rename on same device, copy and unlink original
  # otherwise
  #
  # See FileUtils.mv
  #
  # source://image_optim//lib/image_optim/path.rb#32
  def move(dst); end

  # Atomic replace dst with self
  #
  # source://image_optim//lib/image_optim/path.rb#52
  def replace(dst); end

  # Get temp path for this file with same extension
  #
  # source://image_optim//lib/image_optim/path.rb#16
  def temp_path(*args, &block); end

  protected

  # source://image_optim//lib/image_optim/path.rb#83
  def replace_using_tmp_file(dst); end

  # @return [Boolean]
  #
  # source://image_optim//lib/image_optim/path.rb#79
  def same_dev?(other); end

  # source://image_optim//lib/image_optim/path.rb#91
  def temp_path_with_tmp_ext(*args, &block); end

  class << self
    # Returns path if it is already an instance of this class otherwise new
    # instance
    #
    # source://image_optim//lib/image_optim/path.rb#73
    def convert(path); end
  end
end

# source://image_optim//lib/image_optim/path.rb#9
ImageOptim::Path::NULL = T.let(T.unsafe(nil), String)

# Hold start time and timeout
#
# source://image_optim//lib/image_optim/timer.rb#7
class ImageOptim::Timer
  include ::ImageOptim::ElapsedTime

  # @return [Timer] a new instance of Timer
  #
  # source://image_optim//lib/image_optim/timer.rb#10
  def initialize(seconds); end

  # source://image_optim//lib/image_optim/timer.rb#15
  def elapsed; end

  # source://image_optim//lib/image_optim/timer.rb#19
  def left; end

  # source://image_optim//lib/image_optim/timer.rb#19
  def to_f; end
end

# Denote ternary value (`true`/`false`/`nil`) for worker option
#
# source://image_optim//lib/image_optim/true_false_nil.rb#5
class ImageOptim::TrueFalseNil
  class << self
    # Add handling of ternary value in OptionParser instance, maps `nil` and
    # `'nil'` to `nil`
    #
    # source://image_optim//lib/image_optim/true_false_nil.rb#8
    def add_to_option_parser(option_parser); end

    # Convert everything truthy to `true`, leave `false` and `nil` as is
    #
    # source://image_optim//lib/image_optim/true_false_nil.rb#14
    def convert(value); end
  end
end

# Base class for all workers
#
# source://image_optim//lib/image_optim/worker/class_methods.rb#7
class ImageOptim::Worker
  extend ::ImageOptim::Worker::ClassMethods

  # Configure (raises on extra options)
  #
  # @return [Worker] a new instance of Worker
  #
  # source://image_optim//lib/image_optim/worker.rb#24
  def initialize(image_optim, options = T.unsafe(nil)); end

  # List of formats which worker can optimize
  #
  # source://image_optim//lib/image_optim/worker.rb#50
  def image_formats; end

  # Short inspect
  #
  # source://image_optim//lib/image_optim/worker.rb#86
  def inspect; end

  # Optimize image at src, output at dst, must be overriden in subclass
  # return true on success
  #
  # source://image_optim//lib/image_optim/worker.rb#45
  def optimize(_src, _dst, options = T.unsafe(nil)); end

  # Check if operation resulted in optimized file
  #
  # @return [Boolean]
  #
  # source://image_optim//lib/image_optim/worker.rb#80
  def optimized?(src, dst); end

  # Return hash with worker options
  #
  # source://image_optim//lib/image_optim/worker.rb#35
  def options; end

  # Resolve used bins, raise exception concatenating all messages
  #
  # source://image_optim//lib/image_optim/worker.rb#70
  def resolve_used_bins!; end

  # Ordering in list of workers, 0 by default
  #
  # source://image_optim//lib/image_optim/worker.rb#60
  def run_order; end

  # List of bins used by worker
  #
  # source://image_optim//lib/image_optim/worker.rb#65
  def used_bins; end

  private

  # source://image_optim//lib/image_optim/worker.rb#102
  def assert_no_unknown_options!(options); end

  # Run command setting priority and hiding output
  #
  # source://image_optim//lib/image_optim/worker.rb#126
  def execute(bin, arguments, options); end

  # source://image_optim//lib/image_optim/worker.rb#95
  def parse_options(options); end

  # Forward bin resolving to image_optim
  #
  # source://image_optim//lib/image_optim/worker.rb#112
  def resolve_bin!(bin); end

  # Run command defining environment, setting nice level, removing output and
  # reraising signal exception
  #
  # source://image_optim//lib/image_optim/worker.rb#140
  def run_command(cmd_args, options); end

  # Wrap run_command and output status, elapsed time and command
  #
  # source://image_optim//lib/image_optim/worker.rb#151
  def run_command_verbose(cmd_args, options); end

  # source://image_optim//lib/image_optim/worker.rb#118
  def wrap_resolver_error_message(message); end

  class << self
    # Default init for worker is new
    # Check example of override in gifsicle worker
    def init(*_arg0); end
  end
end

# http://advancemame.sourceforge.net/doc-advpng.html
#
# source://image_optim//lib/image_optim/worker/advpng.rb#9
class ImageOptim::Worker::Advpng < ::ImageOptim::Worker
  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def level; end

  # source://image_optim//lib/image_optim/worker/advpng.rb#24
  def optimize(src, dst, options = T.unsafe(nil)); end

  # source://image_optim//lib/image_optim/worker/advpng.rb#20
  def run_order; end
end

# source://image_optim//lib/image_optim/worker/advpng.rb#10
ImageOptim::Worker::Advpng::LEVEL_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# Class methods of ImageOptim::Worker
#
# source://image_optim//lib/image_optim/worker/class_methods.rb#9
module ImageOptim::Worker::ClassMethods
  # Underscored class name symbol
  #
  # source://image_optim//lib/image_optim/worker/class_methods.rb#26
  def bin_sym; end

  # Create list of workers sorted by run order
  # Workers are initialized with options provided through options_proc
  # Resolve all bins of all workers, if there are errors and
  # skip_missing_workers of image_optim is true - show warnings, otherwise
  # fail with one joint exception
  #
  # source://image_optim//lib/image_optim/worker/class_methods.rb#62
  def create_all(image_optim, &options_proc); end

  # Create hash with format mapped to list of workers sorted by run order
  #
  # source://image_optim//lib/image_optim/worker/class_methods.rb#46
  def create_all_by_format(image_optim, &options_proc); end

  # Remember all classes inheriting from this one
  #
  # source://image_optim//lib/image_optim/worker/class_methods.rb#20
  def inherited(base); end

  # List of available workers
  #
  # source://image_optim//lib/image_optim/worker/class_methods.rb#15
  def klasses; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#38
  def option(name, default, type, description = T.unsafe(nil), &proc); end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#34
  def option_definitions; end

  private

  # source://image_optim//lib/image_optim/worker/class_methods.rb#86
  def init_all(image_optim, &options_proc); end

  class << self
    # @private
    #
    # source://image_optim//lib/image_optim/worker/class_methods.rb#10
    def extended(klass); end
  end
end

# http://www.lcdf.org/gifsicle/
#
# source://image_optim//lib/image_optim/worker/gifsicle.rb#8
class ImageOptim::Worker::Gifsicle < ::ImageOptim::Worker
  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def careful; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def interlace; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def level; end

  # source://image_optim//lib/image_optim/worker/gifsicle.rb#40
  def optimize(src, dst, options = T.unsafe(nil)); end

  class << self
    # If interlace specified initialize one instance
    # Otherwise initialize two, one with interlace off and one with on
    #
    # source://image_optim//lib/image_optim/worker/gifsicle.rb#11
    def init(image_optim, options = T.unsafe(nil)); end
  end
end

# source://image_optim//lib/image_optim/worker/gifsicle.rb#37
ImageOptim::Worker::Gifsicle::CAREFUL_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/gifsicle.rb#19
ImageOptim::Worker::Gifsicle::INTERLACE_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/gifsicle.rb#29
ImageOptim::Worker::Gifsicle::LEVEL_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# http://www.sentex.net/~mwandel/jhead/
#
# Jhead internally uses jpegtran which should be on path
#
# source://image_optim//lib/image_optim/worker/jhead.rb#11
class ImageOptim::Worker::Jhead < ::ImageOptim::Worker
  # Works on jpegs
  #
  # source://image_optim//lib/image_optim/worker/jhead.rb#15
  def image_formats; end

  # source://image_optim//lib/image_optim/worker/jhead.rb#28
  def optimize(src, dst, options = T.unsafe(nil)); end

  # Run first, while exif is still present
  #
  # source://image_optim//lib/image_optim/worker/jhead.rb#20
  def run_order; end

  # source://image_optim//lib/image_optim/worker/jhead.rb#24
  def used_bins; end

  private

  # @return [Boolean]
  #
  # source://image_optim//lib/image_optim/worker/jhead.rb#42
  def oriented?(image); end
end

# not top-left
#
# source://image_optim//lib/image_optim/worker/jhead.rb#12
ImageOptim::Worker::Jhead::ORIENTED = T.let(T.unsafe(nil), Range)

# http://www.kokkonen.net/tjko/projects.html
#
# source://image_optim//lib/image_optim/worker/jpegoptim.rb#9
class ImageOptim::Worker::Jpegoptim < ::ImageOptim::Worker
  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def allow_lossy; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def max_quality; end

  # source://image_optim//lib/image_optim/worker/jpegoptim.rb#50
  def optimize(src, dst, options = T.unsafe(nil)); end

  # Run earlier if max_quality is less than 100
  #
  # source://image_optim//lib/image_optim/worker/jpegoptim.rb#46
  def run_order; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def strip; end
end

# source://image_optim//lib/image_optim/worker/jpegoptim.rb#10
ImageOptim::Worker::Jpegoptim::ALLOW_LOSSY_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/jpegoptim.rb#31
ImageOptim::Worker::Jpegoptim::MAX_QUALITY_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/jpegoptim.rb#13
ImageOptim::Worker::Jpegoptim::STRIP_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# https://github.com/danielgtaylor/jpeg-archive#jpeg-recompress
#
# source://image_optim//lib/image_optim/worker/jpegrecompress.rb#9
class ImageOptim::Worker::Jpegrecompress < ::ImageOptim::Worker
  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def allow_lossy; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def method; end

  # source://image_optim//lib/image_optim/worker/jpegrecompress.rb#52
  def optimize(src, dst, options = T.unsafe(nil)); end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def quality; end

  # Run early as lossy worker
  #
  # source://image_optim//lib/image_optim/worker/jpegrecompress.rb#48
  def run_order; end

  # source://image_optim//lib/image_optim/worker/jpegrecompress.rb#43
  def used_bins; end

  class << self
    # Initialize only if allow_lossy
    #
    # source://image_optim//lib/image_optim/worker/jpegrecompress.rb#14
    def init(image_optim, options = T.unsafe(nil)); end
  end
end

# source://image_optim//lib/image_optim/worker/jpegrecompress.rb#10
ImageOptim::Worker::Jpegrecompress::ALLOW_LOSSY_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/jpegrecompress.rb#29
ImageOptim::Worker::Jpegrecompress::METHOD_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/jpegrecompress.rb#18
ImageOptim::Worker::Jpegrecompress::QUALITY_NAMES = T.let(T.unsafe(nil), Array)

# source://image_optim//lib/image_optim/worker/jpegrecompress.rb#24
ImageOptim::Worker::Jpegrecompress::QUALITY_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# http://www.ijg.org/
#
# Uses jpegtran through jpegrescan if enabled, jpegrescan is vendored with
# this gem
#
# source://image_optim//lib/image_optim/worker/jpegtran.rb#11
class ImageOptim::Worker::Jpegtran < ::ImageOptim::Worker
  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def copy_chunks; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def jpegrescan; end

  # source://image_optim//lib/image_optim/worker/jpegtran.rb#26
  def optimize(src, dst, options = T.unsafe(nil)); end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def progressive; end

  # source://image_optim//lib/image_optim/worker/jpegtran.rb#22
  def used_bins; end
end

# source://image_optim//lib/image_optim/worker/jpegtran.rb#12
ImageOptim::Worker::Jpegtran::COPY_CHUNKS_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/jpegtran.rb#18
ImageOptim::Worker::Jpegtran::JPEGRESCAN_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/jpegtran.rb#15
ImageOptim::Worker::Jpegtran::PROGRESSIVE_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# http://optipng.sourceforge.net/
#
# source://image_optim//lib/image_optim/worker/optipng.rb#10
class ImageOptim::Worker::Optipng < ::ImageOptim::Worker
  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def interlace; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def level; end

  # source://image_optim//lib/image_optim/worker/optipng.rb#33
  def optimize(src, dst, options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://image_optim//lib/image_optim/worker/optipng.rb#48
  def optimized?(src, dst); end

  # source://image_optim//lib/image_optim/worker/optipng.rb#29
  def run_order; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def strip; end
end

# source://image_optim//lib/image_optim/worker/optipng.rb#18
ImageOptim::Worker::Optipng::INTERLACE_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/optipng.rb#11
ImageOptim::Worker::Optipng::LEVEL_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/optipng.rb#26
ImageOptim::Worker::Optipng::STRIP_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# https://github.com/shssoichiro/oxipng
#
# source://image_optim//lib/image_optim/worker/oxipng.rb#10
class ImageOptim::Worker::Oxipng < ::ImageOptim::Worker
  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def interlace; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def level; end

  # source://image_optim//lib/image_optim/worker/oxipng.rb#33
  def optimize(src, dst, options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://image_optim//lib/image_optim/worker/oxipng.rb#48
  def optimized?(src, dst); end

  # source://image_optim//lib/image_optim/worker/oxipng.rb#29
  def run_order; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def strip; end
end

# source://image_optim//lib/image_optim/worker/oxipng.rb#18
ImageOptim::Worker::Oxipng::INTERLACE_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/oxipng.rb#11
ImageOptim::Worker::Oxipng::LEVEL_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/oxipng.rb#26
ImageOptim::Worker::Oxipng::STRIP_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# http://pmt.sourceforge.net/pngcrush/
#
# source://image_optim//lib/image_optim/worker/pngcrush.rb#8
class ImageOptim::Worker::Pngcrush < ::ImageOptim::Worker
  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def blacken; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def brute; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def chunks; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def fix; end

  # source://image_optim//lib/image_optim/worker/pngcrush.rb#31
  def optimize(src, dst, options = T.unsafe(nil)); end

  # source://image_optim//lib/image_optim/worker/pngcrush.rb#27
  def run_order; end
end

# source://image_optim//lib/image_optim/worker/pngcrush.rb#24
ImageOptim::Worker::Pngcrush::BLACKEN_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/pngcrush.rb#20
ImageOptim::Worker::Pngcrush::BRUTE_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/pngcrush.rb#9
ImageOptim::Worker::Pngcrush::CHUNKS_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/pngcrush.rb#16
ImageOptim::Worker::Pngcrush::FIX_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# http://www.advsys.net/ken/util/pngout.htm
#
# source://image_optim//lib/image_optim/worker/pngout.rb#9
class ImageOptim::Worker::Pngout < ::ImageOptim::Worker
  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def copy_chunks; end

  # source://image_optim//lib/image_optim/worker/pngout.rb#27
  def optimize(src, dst, options = T.unsafe(nil)); end

  # source://image_optim//lib/image_optim/worker/pngout.rb#23
  def run_order; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def strategy; end
end

# source://image_optim//lib/image_optim/worker/pngout.rb#10
ImageOptim::Worker::Pngout::COPY_CHUNKS_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/pngout.rb#13
ImageOptim::Worker::Pngout::STRATEGY_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# http://pngquant.org/
#
# source://image_optim//lib/image_optim/worker/pngquant.rb#10
class ImageOptim::Worker::Pngquant < ::ImageOptim::Worker
  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def allow_lossy; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def max_colors; end

  # source://image_optim//lib/image_optim/worker/pngquant.rb#53
  def optimize(src, dst, options = T.unsafe(nil)); end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def quality; end

  # source://image_optim//lib/image_optim/worker/pngquant.rb#49
  def run_order; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def speed; end
end

# source://image_optim//lib/image_optim/worker/pngquant.rb#11
ImageOptim::Worker::Pngquant::ALLOW_LOSSY_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/pngquant.rb#14
ImageOptim::Worker::Pngquant::MAX_COLORS_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/pngquant.rb#19
ImageOptim::Worker::Pngquant::QUALITY_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/pngquant.rb#41
ImageOptim::Worker::Pngquant::SPEED_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# https://github.com/svg/svgo
#
# source://image_optim//lib/image_optim/worker/svgo.rb#8
class ImageOptim::Worker::Svgo < ::ImageOptim::Worker
  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def disable_plugins; end

  # source://image_optim//lib/image_optim/worker/class_methods.rb#39
  def enable_plugins; end

  # source://image_optim//lib/image_optim/worker/svgo.rb#19
  def optimize(src, dst, options = T.unsafe(nil)); end
end

# source://image_optim//lib/image_optim/worker/svgo.rb#9
ImageOptim::Worker::Svgo::DISABLE_PLUGINS_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)

# source://image_optim//lib/image_optim/worker/svgo.rb#14
ImageOptim::Worker::Svgo::ENABLE_PLUGINS_OPTION = T.let(T.unsafe(nil), ImageOptim::OptionDefinition)
