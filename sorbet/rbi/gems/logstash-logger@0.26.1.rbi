# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `logstash-logger` gem.
# Please instead update this file by running `bin/tapioca gem logstash-logger`.

# Add support for Rails-style logger silencing. Thread-safe and no dependencies.
#
# Setup:
#   logger = Logger.new(STDOUT)
#   logger.extend(LogStashLogger::SilencedLogging)
#
# Usage:
#
#   logger.silence do
#     ...
#   end
#
# source://logstash-logger//lib/logstash-logger/version.rb#1
module LogStashLogger
  class << self
    # source://logstash-logger//lib/logstash-logger/logger.rb#71
    def build_default_logger(opts); end

    # source://logstash-logger//lib/logstash-logger/logger.rb#52
    def build_logger(opts); end

    # source://logstash-logger//lib/logstash-logger/logger.rb#80
    def build_multi_logger(opts); end

    # source://logstash-logger//lib/logstash-logger/logger.rb#89
    def build_syslog_logger(opts); end

    # source://logstash-logger//lib/logstash-logger/configuration.rb#3
    def configuration(&block); end

    # source://logstash-logger//lib/logstash-logger/configuration.rb#3
    def configure(&block); end

    # source://logstash-logger//lib/logstash-logger/logger.rb#101
    def extend_logger(logger); end

    # @private
    #
    # source://logstash-logger//lib/logstash-logger/logger.rb#13
    def extended(base); end

    # source://logstash-logger//lib/logstash-logger/logger.rb#31
    def extract_opts(*args); end

    # source://logstash-logger//lib/logstash-logger/logger.rb#8
    def new(*args); end

    # source://logstash-logger//lib/logstash-logger/railtie.rb#24
    def sanitize_logger_options(app, logger_options); end

    # source://logstash-logger//lib/logstash-logger/railtie.rb#4
    def setup(app); end
  end
end

# Implements a generic framework for accepting events which are later flushed
# in batches. Flushing occurs whenever +:max_items+ or +:max_interval+ (seconds)
# has been reached.
#
# Including class must implement +flush+, which will be called with all
# accumulated items either when the output buffer fills (+:max_items+) or
# when a fixed amount of time (+:max_interval+) passes.
#
# == batch_receive and flush
# General receive/flush can be implemented in one of two ways.
#
# === batch_receive(event) / flush(events)
# +flush+ will receive an array of events which were passed to +buffer_receive+.
#
#   batch_receive('one')
#   batch_receive('two')
#
# will cause a flush invocation like
#
#   flush(['one', 'two'])
#
# === batch_receive(event, group) / flush(events, group)
# flush() will receive an array of events, plus a grouping key.
#
#   batch_receive('one',   :server => 'a')
#   batch_receive('two',   :server => 'b')
#   batch_receive('three', :server => 'a')
#   batch_receive('four',  :server => 'b')
#
# will result in the following flush calls
#
#   flush(['one', 'three'], {:server => 'a'})
#   flush(['two', 'four'],  {:server => 'b'})
#
# Grouping keys can be anything which are valid Hash keys. (They don't have to
# be hashes themselves.) Strings or Fixnums work fine. Use anything which you'd
# like to receive in your +flush+ method to help enable different handling for
# various groups of events.
#
# == on_flush_error
# Including class may implement +on_flush_error+, which will be called with an
# Exception instance whenever buffer_flush encounters an error.
#
# * +buffer_flush+ will automatically re-try failed flushes, so +on_flush_error+
#   should not try to implement retry behavior.
# * Exceptions occurring within +on_flush_error+ are not handled by
#   +buffer_flush+.
#
# == on_full_buffer_receive
# Including class may implement +on_full_buffer_receive+, which will be called
# whenever +buffer_receive+ is called while the buffer is full.
#
# +on_full_buffer_receive+ will receive a Hash like <code>{:pending => 30,
# :outgoing => 20}</code> which describes the internal state of the module at
# the moment.
#
# == final flush
# Including class should call <code>buffer_flush(:final => true)</code>
# during a teardown/shutdown routine (after the last call to buffer_receive)
# to ensure that all accumulated messages are flushed.
#
# @author {Alex Dean}[http://github.com/alexdean]
#
# source://logstash-logger//lib/logstash-logger/buffer.rb#67
module LogStashLogger::Buffer
  # Try to flush events.
  #
  # Returns immediately if flushing is not necessary/possible at the moment:
  # * :max_items have not been accumulated
  # * :max_interval seconds have not elapased since the last flush
  # * another flush is in progress
  #
  # <code>buffer_flush(:force => true)</code> will cause a flush to occur even
  # if +:max_items+ or +:max_interval+ have not been reached. A forced flush
  # will still return immediately (without flushing) if another flush is
  # currently in progress.
  #
  # <code>buffer_flush(:final => true)</code> is identical to <code>buffer_flush(:force => true)</code>,
  # except that if another flush is already in progress, <code>buffer_flush(:final => true)</code>
  # will block/wait for the other flush to finish before proceeding.
  #
  # @param options [Hash] Optional. May be <code>{:force => true}</code> or <code>{:final => true}</code>.
  # @return [Fixnum] The number of items successfully passed to +flush+.
  #
  # source://logstash-logger//lib/logstash-logger/buffer.rb#202
  def buffer_flush(options = T.unsafe(nil)); end

  # Determine if +:max_items+ has been reached.
  #
  # buffer_receive calls will block while <code>buffer_full? == true</code>.
  #
  # @return [bool] Is the buffer full?
  #
  # source://logstash-logger//lib/logstash-logger/buffer.rb#141
  def buffer_full?; end

  # Initialize the buffer.
  #
  # Call directly from your constructor if you wish to set some non-default
  # options. Otherwise buffer_initialize will be called automatically during the
  # first buffer_receive call.
  #
  # Options:
  # * :max_items, Max number of items to buffer before flushing. Default 50.
  # * :max_interval, Max number of seconds to wait between flushes. Default 5.
  # * :logger, A logger to write log messages to. No default. Optional.
  # * :autoflush, Whether to immediately flush all inbound messages. Default true.
  # * :drop_messages_on_flush_error, Whether to drop messages when there is a flush error. Default false.
  # * :drop_messages_on_full_buffer, Whether to drop messages when the buffer is full. Default false.
  #
  # @param options [Hash]
  #
  # source://logstash-logger//lib/logstash-logger/buffer.rb#85
  def buffer_initialize(options = T.unsafe(nil)); end

  # Save an event for later delivery
  #
  # Events are grouped by the (optional) group parameter you provide.
  # Groups of events, plus the group name, are later passed to +flush+.
  #
  # This call will block if +:max_items+ has been reached.
  #
  # @param event An item to buffer for flushing later.
  # @param group Optional grouping key. All events with the same key will be
  #   passed to +flush+ together, along with the grouping key itself.
  # @see Stud::Buffer The overview has more information on grouping and flushing.
  #
  # source://logstash-logger//lib/logstash-logger/buffer.rb#157
  def buffer_receive(event, group = T.unsafe(nil)); end

  # source://logstash-logger//lib/logstash-logger/buffer.rb#109
  def reset_buffer; end

  private

  # source://logstash-logger//lib/logstash-logger/buffer.rb#321
  def buffer_clear_outgoing; end

  # source://logstash-logger//lib/logstash-logger/buffer.rb#316
  def buffer_clear_pending; end

  # source://logstash-logger//lib/logstash-logger/buffer.rb#326
  def cancel_flush; end

  # source://logstash-logger//lib/logstash-logger/buffer.rb#292
  def flush_mutex; end

  # source://logstash-logger//lib/logstash-logger/buffer.rb#296
  def flush_timer_thread; end

  # source://logstash-logger//lib/logstash-logger/buffer.rb#288
  def pending_mutex; end

  # source://logstash-logger//lib/logstash-logger/buffer.rb#309
  def reset_flush_timer_thread; end
end

# source://logstash-logger//lib/logstash-logger/configuration.rb#11
class LogStashLogger::Configuration
  # @return [Configuration] a new instance of Configuration
  # @yield [_self]
  # @yieldparam _self [LogStashLogger::Configuration] the object that the method was called on
  #
  # source://logstash-logger//lib/logstash-logger/configuration.rb#16
  def initialize(*args); end

  # source://logstash-logger//lib/logstash-logger/configuration.rb#24
  def customize_event(&block); end

  # Returns the value of attribute customize_event_block.
  #
  # source://logstash-logger//lib/logstash-logger/configuration.rb#12
  def customize_event_block; end

  # Sets the attribute customize_event_block
  #
  # @param value the value to set the attribute customize_event_block to.
  #
  # source://logstash-logger//lib/logstash-logger/configuration.rb#12
  def customize_event_block=(_arg0); end

  # Returns the value of attribute default_error_logger.
  #
  # source://logstash-logger//lib/logstash-logger/configuration.rb#14
  def default_error_logger; end

  # Sets the attribute default_error_logger
  #
  # @param value the value to set the attribute default_error_logger to.
  #
  # source://logstash-logger//lib/logstash-logger/configuration.rb#14
  def default_error_logger=(_arg0); end

  # Returns the value of attribute max_message_size.
  #
  # source://logstash-logger//lib/logstash-logger/configuration.rb#13
  def max_message_size; end

  # Sets the attribute max_message_size
  #
  # @param value the value to set the attribute max_message_size to.
  #
  # source://logstash-logger//lib/logstash-logger/configuration.rb#13
  def max_message_size=(_arg0); end
end

# source://logstash-logger//lib/logstash-logger/device/base.rb#2
module LogStashLogger::Device
  class << self
    # source://logstash-logger//lib/logstash-logger/device.rb#29
    def build_device(opts); end

    # source://logstash-logger//lib/logstash-logger/device.rb#48
    def device_klass_for(type); end

    # source://logstash-logger//lib/logstash-logger/device.rb#24
    def new(opts); end

    # source://logstash-logger//lib/logstash-logger/device.rb#40
    def parse_uri_config(opts); end
  end
end

# source://logstash-logger//lib/logstash-logger/device/balancer.rb#3
class LogStashLogger::Device::Balancer < ::LogStashLogger::Device::Base
  # @return [Balancer] a new instance of Balancer
  #
  # source://logstash-logger//lib/logstash-logger/device/balancer.rb#6
  def initialize(opts); end

  # Returns the value of attribute devices.
  #
  # source://logstash-logger//lib/logstash-logger/device/balancer.rb#4
  def devices; end

  private

  # source://logstash-logger//lib/logstash-logger/device/balancer.rb#15
  def create_devices(opts); end

  # source://logstash-logger//lib/logstash-logger/device/balancer.rb#35
  def select_device; end

  class << self
    # source://logstash-logger//lib/logstash-logger/device/balancer.rb#19
    def delegate_to_all(*methods); end

    # source://logstash-logger//lib/logstash-logger/device/balancer.rb#27
    def delegate_to_one(*methods); end
  end
end

# source://logstash-logger//lib/logstash-logger/device/base.rb#3
class LogStashLogger::Device::Base
  # @return [Base] a new instance of Base
  #
  # source://logstash-logger//lib/logstash-logger/device/base.rb#8
  def initialize(opts = T.unsafe(nil)); end

  # source://logstash-logger//lib/logstash-logger/device/base.rb#46
  def close(opts = T.unsafe(nil)); end

  # source://logstash-logger//lib/logstash-logger/device/base.rb#52
  def close!; end

  # Returns the value of attribute error_logger.
  #
  # source://logstash-logger//lib/logstash-logger/device/base.rb#6
  def error_logger; end

  # Sets the attribute error_logger
  #
  # @param value the value to set the attribute error_logger to.
  #
  # source://logstash-logger//lib/logstash-logger/device/base.rb#6
  def error_logger=(_arg0); end

  # source://logstash-logger//lib/logstash-logger/device/base.rb#38
  def flush; end

  # Returns the value of attribute io.
  #
  # source://logstash-logger//lib/logstash-logger/device/base.rb#4
  def io; end

  # source://logstash-logger//lib/logstash-logger/device/base.rb#42
  def reset; end

  # Returns the value of attribute sync.
  #
  # source://logstash-logger//lib/logstash-logger/device/base.rb#5
  def sync; end

  # Sets the attribute sync
  #
  # @param value the value to set the attribute sync to.
  #
  # source://logstash-logger//lib/logstash-logger/device/base.rb#5
  def sync=(_arg0); end

  # source://logstash-logger//lib/logstash-logger/device/base.rb#13
  def to_io; end

  # @return [Boolean]
  #
  # source://logstash-logger//lib/logstash-logger/device/base.rb#58
  def unrecoverable_error?(e); end

  # source://logstash-logger//lib/logstash-logger/device/base.rb#17
  def write(message); end

  # source://logstash-logger//lib/logstash-logger/device/base.rb#32
  def write_batch(messages, group = T.unsafe(nil)); end

  # source://logstash-logger//lib/logstash-logger/device/base.rb#21
  def write_one(message); end

  private

  # source://logstash-logger//lib/logstash-logger/device/base.rb#64
  def log_error(e); end

  # source://logstash-logger//lib/logstash-logger/device/base.rb#68
  def log_warning(message); end
end

# source://logstash-logger//lib/logstash-logger/device/connectable.rb#5
class LogStashLogger::Device::Connectable < ::LogStashLogger::Device::Base
  include ::LogStashLogger::Buffer

  # @return [Connectable] a new instance of Connectable
  #
  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#10
  def initialize(opts = T.unsafe(nil)); end

  # Returns the value of attribute buffer_logger.
  #
  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#8
  def buffer_logger; end

  # Sets the attribute buffer_logger
  #
  # @param value the value to set the attribute buffer_logger to.
  #
  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#8
  def buffer_logger=(_arg0); end

  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#75
  def close(opts = T.unsafe(nil)); end

  # Implemented by subclasses
  #
  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#106
  def connect; end

  # @return [Boolean]
  #
  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#89
  def connected?; end

  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#62
  def flush(*args); end

  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#71
  def on_full_buffer_receive(data); end

  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#115
  def reconnect; end

  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#110
  def reset; end

  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#83
  def to_io; end

  # Ensure the block is executed with a valid connection
  #
  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#121
  def with_connection(&block); end

  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#58
  def write(message); end

  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#99
  def write_batch(messages, group = T.unsafe(nil)); end

  # source://logstash-logger//lib/logstash-logger/device/connectable.rb#93
  def write_one(message); end
end

# source://logstash-logger//lib/logstash-logger/device.rb#5
LogStashLogger::Device::DEFAULT_TYPE = T.let(T.unsafe(nil), Symbol)

# source://logstash-logger//lib/logstash-logger/device/file.rb#5
class LogStashLogger::Device::File < ::LogStashLogger::Device::Base
  # @return [File] a new instance of File
  #
  # source://logstash-logger//lib/logstash-logger/device/file.rb#6
  def initialize(opts); end

  # source://logstash-logger//lib/logstash-logger/device/file.rb#12
  def open; end
end

# source://logstash-logger//lib/logstash-logger/device/io.rb#3
class LogStashLogger::Device::IO < ::LogStashLogger::Device::Base
  # @return [IO] a new instance of IO
  #
  # source://logstash-logger//lib/logstash-logger/device/io.rb#4
  def initialize(opts); end
end

# source://logstash-logger//lib/logstash-logger/device/multi_delegator.rb#8
class LogStashLogger::Device::MultiDelegator < ::LogStashLogger::Device::Base
  # @return [MultiDelegator] a new instance of MultiDelegator
  #
  # source://logstash-logger//lib/logstash-logger/device/multi_delegator.rb#11
  def initialize(opts); end

  # Returns the value of attribute devices.
  #
  # source://logstash-logger//lib/logstash-logger/device/multi_delegator.rb#9
  def devices; end

  private

  # source://logstash-logger//lib/logstash-logger/device/multi_delegator.rb#19
  def create_devices(opts); end

  class << self
    # source://logstash-logger//lib/logstash-logger/device/multi_delegator.rb#27
    def delegate(*methods); end
  end
end

# source://logstash-logger//lib/logstash-logger/device/redis.rb#5
class LogStashLogger::Device::Redis < ::LogStashLogger::Device::Connectable
  # @return [Redis] a new instance of Redis
  #
  # source://logstash-logger//lib/logstash-logger/device/redis.rb#10
  def initialize(opts); end

  # source://logstash-logger//lib/logstash-logger/device/redis.rb#53
  def close!; end

  # source://logstash-logger//lib/logstash-logger/device/redis.rb#20
  def connect; end

  # Returns the value of attribute list.
  #
  # source://logstash-logger//lib/logstash-logger/device/redis.rb#8
  def list; end

  # Sets the attribute list
  #
  # @param value the value to set the attribute list to.
  #
  # source://logstash-logger//lib/logstash-logger/device/redis.rb#8
  def list=(_arg0); end

  # source://logstash-logger//lib/logstash-logger/device/redis.rb#24
  def reconnect; end

  # source://logstash-logger//lib/logstash-logger/device/redis.rb#30
  def with_connection; end

  # source://logstash-logger//lib/logstash-logger/device/redis.rb#42
  def write_batch(messages, list = T.unsafe(nil)); end

  # source://logstash-logger//lib/logstash-logger/device/redis.rb#49
  def write_one(message, list = T.unsafe(nil)); end

  private

  # source://logstash-logger//lib/logstash-logger/device/redis.rb#59
  def normalize_path(opts); end
end

# source://logstash-logger//lib/logstash-logger/device/redis.rb#6
LogStashLogger::Device::Redis::DEFAULT_LIST = T.let(T.unsafe(nil), String)

# source://logstash-logger//lib/logstash-logger/device/socket.rb#5
class LogStashLogger::Device::Socket < ::LogStashLogger::Device::Connectable
  # @return [Socket] a new instance of Socket
  #
  # source://logstash-logger//lib/logstash-logger/device/socket.rb#10
  def initialize(opts); end

  # Returns the value of attribute host.
  #
  # source://logstash-logger//lib/logstash-logger/device/socket.rb#8
  def host; end

  # Returns the value of attribute port.
  #
  # source://logstash-logger//lib/logstash-logger/device/socket.rb#8
  def port; end

  # @return [Boolean]
  #
  # source://logstash-logger//lib/logstash-logger/device/socket.rb#16
  def unrecoverable_error?(e); end
end

# source://logstash-logger//lib/logstash-logger/device/socket.rb#6
LogStashLogger::Device::Socket::DEFAULT_HOST = T.let(T.unsafe(nil), String)

# source://logstash-logger//lib/logstash-logger/device/stderr.rb#3
class LogStashLogger::Device::Stderr < ::LogStashLogger::Device::IO
  # @return [Stderr] a new instance of Stderr
  #
  # source://logstash-logger//lib/logstash-logger/device/stderr.rb#4
  def initialize(opts = T.unsafe(nil)); end

  # source://logstash-logger//lib/logstash-logger/device/stderr.rb#8
  def close!; end
end

# source://logstash-logger//lib/logstash-logger/device/stdout.rb#3
class LogStashLogger::Device::Stdout < ::LogStashLogger::Device::IO
  # @return [Stdout] a new instance of Stdout
  #
  # source://logstash-logger//lib/logstash-logger/device/stdout.rb#4
  def initialize(opts = T.unsafe(nil)); end

  # source://logstash-logger//lib/logstash-logger/device/stdout.rb#8
  def close!; end
end

# source://logstash-logger//lib/logstash-logger/device/tcp.rb#5
class LogStashLogger::Device::TCP < ::LogStashLogger::Device::Socket
  # @return [TCP] a new instance of TCP
  #
  # source://logstash-logger//lib/logstash-logger/device/tcp.rb#8
  def initialize(opts); end

  # source://logstash-logger//lib/logstash-logger/device/tcp.rb#31
  def connect; end

  # source://logstash-logger//lib/logstash-logger/device/tcp.rb#39
  def io; end

  # Returns the value of attribute ssl_certificate.
  #
  # source://logstash-logger//lib/logstash-logger/device/tcp.rb#6
  def ssl_certificate; end

  # source://logstash-logger//lib/logstash-logger/device/tcp.rb#22
  def ssl_context; end

  # @return [Boolean]
  #
  # source://logstash-logger//lib/logstash-logger/device/tcp.rb#27
  def use_ssl?; end

  protected

  # source://logstash-logger//lib/logstash-logger/device/tcp.rb#61
  def certificate_context; end

  # source://logstash-logger//lib/logstash-logger/device/tcp.rb#77
  def hostname; end

  # source://logstash-logger//lib/logstash-logger/device/tcp.rb#55
  def ssl_io; end

  # source://logstash-logger//lib/logstash-logger/device/tcp.rb#49
  def tcp_io; end

  # source://logstash-logger//lib/logstash-logger/device/tcp.rb#73
  def verify_hostname!; end

  # @return [Boolean]
  #
  # source://logstash-logger//lib/logstash-logger/device/tcp.rb#68
  def verify_hostname?; end
end

# source://logstash-logger//lib/logstash-logger/device/udp.rb#3
class LogStashLogger::Device::UDP < ::LogStashLogger::Device::Socket
  # source://logstash-logger//lib/logstash-logger/device/udp.rb#4
  def connect; end
end

# source://logstash-logger//lib/logstash-logger/device/unix.rb#5
class LogStashLogger::Device::Unix < ::LogStashLogger::Device::Connectable
  # @return [Unix] a new instance of Unix
  #
  # source://logstash-logger//lib/logstash-logger/device/unix.rb#6
  def initialize(opts = T.unsafe(nil)); end

  # source://logstash-logger//lib/logstash-logger/device/unix.rb#11
  def connect; end
end

# source://logstash-logger//lib/logstash-logger/formatter/base.rb#6
module LogStashLogger::Formatter
  class << self
    # source://logstash-logger//lib/logstash-logger/formatter.rb#17
    def build_formatter(formatter_type, customize_event); end

    # @return [Boolean]
    #
    # source://logstash-logger//lib/logstash-logger/formatter.rb#47
    def custom_formatter_class?(formatter_type); end

    # @return [Boolean]
    #
    # source://logstash-logger//lib/logstash-logger/formatter.rb#43
    def custom_formatter_instance?(formatter_type); end

    # source://logstash-logger//lib/logstash-logger/formatter.rb#32
    def formatter_klass(formatter_type); end

    # source://logstash-logger//lib/logstash-logger/formatter.rb#13
    def new(formatter_type, customize_event: T.unsafe(nil)); end
  end
end

# source://logstash-logger//lib/logstash-logger/formatter/base.rb#9
class LogStashLogger::Formatter::Base < ::Logger::Formatter
  include ::LogStashLogger::TaggedLogging::Formatter

  # @return [Base] a new instance of Base
  #
  # source://logstash-logger//lib/logstash-logger/formatter/base.rb#12
  def initialize(customize_event: T.unsafe(nil)); end

  # source://logstash-logger//lib/logstash-logger/formatter/base.rb#17
  def call(severity, time, _progname, message); end

  private

  # source://logstash-logger//lib/logstash-logger/formatter/base.rb#24
  def build_event(message, severity, time); end

  # source://logstash-logger//lib/logstash-logger/formatter/base.rb#68
  def format_event(event); end
end

# source://logstash-logger//lib/logstash-logger/formatter/cee.rb#3
class LogStashLogger::Formatter::Cee < ::LogStashLogger::Formatter::Base
  private

  # source://logstash-logger//lib/logstash-logger/formatter/cee.rb#6
  def format_event(event); end
end

# source://logstash-logger//lib/logstash-logger/formatter/cee_syslog.rb#3
class LogStashLogger::Formatter::CeeSyslog < ::LogStashLogger::Formatter::Cee
  # source://logstash-logger//lib/logstash-logger/formatter/cee_syslog.rb#4
  def call(severity, time, progname, message); end

  private

  # source://logstash-logger//lib/logstash-logger/formatter/cee_syslog.rb#11
  def build_facility(host); end

  # source://logstash-logger//lib/logstash-logger/formatter/cee_syslog.rb#17
  def format_event(event); end
end

# source://logstash-logger//lib/logstash-logger/formatter.rb#5
LogStashLogger::Formatter::DEFAULT_FORMATTER = T.let(T.unsafe(nil), Symbol)

# source://logstash-logger//lib/logstash-logger/formatter/base.rb#7
LogStashLogger::Formatter::HOST = T.let(T.unsafe(nil), String)

# source://logstash-logger//lib/logstash-logger/formatter/json.rb#3
class LogStashLogger::Formatter::Json < ::LogStashLogger::Formatter::Base
  private

  # source://logstash-logger//lib/logstash-logger/formatter/json.rb#6
  def format_event(event); end
end

# source://logstash-logger//lib/logstash-logger/formatter/json_lines.rb#3
class LogStashLogger::Formatter::JsonLines < ::LogStashLogger::Formatter::Base
  private

  # source://logstash-logger//lib/logstash-logger/formatter/json_lines.rb#6
  def format_event(event); end
end

# source://logstash-logger//lib/logstash-logger/formatter/logstash_event.rb#3
class LogStashLogger::Formatter::LogStashEvent < ::LogStashLogger::Formatter::Base; end

# source://logstash-logger//lib/logstash-logger/multi_logger.rb#3
class LogStashLogger::MultiLogger < ::Logger
  # === Synopsis
  #
  #   MultiLogger.new([logger1, logger2])
  #
  # === Args
  #
  # +loggers+::
  #   An array of loggers. Each one gets every message that is sent to the MultiLogger instance
  #
  # === Description
  #
  # Create an instance.
  #
  # @return [MultiLogger] a new instance of MultiLogger
  #
  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#92
  def initialize(loggers); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#105
  def <<(msg); end

  # Methods that write to logs just write to each contained logger in turn
  #
  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#99
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#147
  def close; end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#21
  def datetime_format=(datetime_format); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#111
  def debug(progname = T.unsafe(nil), &block); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#129
  def error(progname = T.unsafe(nil), &block); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#135
  def fatal(progname = T.unsafe(nil), &block); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#28
  def formatter=(formatter); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#117
  def info(progname = T.unsafe(nil), &block); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#7
  def level=(value); end

  # Array of Loggers to be logged to. These can be anything that acts reasonably like a Logger.
  #
  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#5
  def loggers; end

  # Array of Loggers to be logged to. These can be anything that acts reasonably like a Logger.
  #
  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#5
  def loggers=(_arg0); end

  # Any method not defined on standard Logger class, just send it on to anyone who will listen
  #
  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#70
  def method_missing(name, *args, &block); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#14
  def progname=(value); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#35
  def silence(temporary_level = T.unsafe(nil), &block); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#52
  def tagged(*tags, &block); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#141
  def unknown(progname = T.unsafe(nil), &block); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#123
  def warn(progname = T.unsafe(nil), &block); end

  private

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#43
  def silence_loggers(temporary_level = T.unsafe(nil), silenceable_loggers, &block); end

  # source://logstash-logger//lib/logstash-logger/multi_logger.rb#60
  def tag_loggers(tags, taggable_loggers, &block); end
end

# source://logstash-logger//lib/logstash-logger/railtie.rb#44
class LogStashLogger::Railtie < ::Rails::Railtie; end

# source://logstash-logger//lib/logstash-logger/silenced_logging.rb#20
module LogStashLogger::SilencedLogging
  # source://logstash-logger//lib/logstash-logger/silenced_logging.rb#55
  def add_with_thread_safety(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://logstash-logger//lib/logstash-logger/silenced_logging.rb#51
  def level_with_thread_safety; end

  # Silences the logger for the duration of the block.
  #
  # source://logstash-logger//lib/logstash-logger/silenced_logging.rb#64
  def silence(temporary_level = T.unsafe(nil)); end

  # source://logstash-logger//lib/logstash-logger/silenced_logging.rb#43
  def thread_level; end

  # source://logstash-logger//lib/logstash-logger/silenced_logging.rb#47
  def thread_level=(level); end

  private

  # source://logstash-logger//lib/logstash-logger/silenced_logging.rb#79
  def thread_hash_level_key; end

  class << self
    # @private
    #
    # source://logstash-logger//lib/logstash-logger/silenced_logging.rb#21
    def extended(logger); end
  end
end

# Shamelessly copied from ActiveSupport::TaggedLogging
#
# source://logstash-logger//lib/logstash-logger/tagged_logging.rb#3
module LogStashLogger::TaggedLogging
  # source://logstash-logger//lib/logstash-logger/tagged_logging.rb#8
  def flush; end

  # source://logstash-logger//lib/logstash-logger/tagged_logging.rb#4
  def tagged(*tags); end
end

# source://logstash-logger//lib/logstash-logger/tagged_logging.rb#13
module LogStashLogger::TaggedLogging::Formatter
  # source://logstash-logger//lib/logstash-logger/tagged_logging.rb#31
  def clear_tags!; end

  # source://logstash-logger//lib/logstash-logger/tagged_logging.rb#35
  def current_tags; end

  # source://logstash-logger//lib/logstash-logger/tagged_logging.rb#27
  def pop_tags(size = T.unsafe(nil)); end

  # source://logstash-logger//lib/logstash-logger/tagged_logging.rb#21
  def push_tags(*tags); end

  # source://logstash-logger//lib/logstash-logger/tagged_logging.rb#14
  def tagged(*tags); end
end

# source://logstash-logger//lib/logstash-logger/version.rb#2
LogStashLogger::VERSION = T.let(T.unsafe(nil), String)
