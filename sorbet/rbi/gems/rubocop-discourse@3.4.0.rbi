# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-discourse` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-discourse`.

# source://rubocop-discourse//lib/rubocop/discourse.rb#3
module RuboCop; end

# source://rubocop-discourse//lib/rubocop/cop/discourse/no_add_reference_active_record_migrations.rb#4
module RuboCop::Cop; end

# source://rubocop-discourse//lib/rubocop/cop/discourse/no_add_reference_active_record_migrations.rb#5
module RuboCop::Cop::Discourse; end

# The methods:
#
# * add_reference
# * add_belongs_to
# * t.references
# * t.belongs_to
#
# in ActiveRecord migrations are magic, and they all do
# some unexpected things in the background. For example, by default
# add_reference adds an index at the same time, but not concurrently,
# which is a nightmare for large tables.
#
# Instead, inside a disable_ddl_transaction! migration we should create
# the new column (with any defaults and options required) and the index
# concurrently using hand-written SQL. This also allows us to handle
# IF NOT EXISTS cases, which enable re-runnable migrations. Also we
# can pick a better name for the index at the same time.
#
# # bad
# def up
#   add_reference :posts, :image_upload
#   # or add_belongs_to :posts, :image_upload
#   # or t.references :image_upload when doing create_table do |t|
#   # or t.belongs_to :image_upload when doing create_table do |t|
# end
#
# # good
# disable_ddl_transaction!
# def up
#   execute <<~SQL
#     ALTER TABLE posts
#     ADD COLUMN IF NOT EXISTS image_upload_id bigint
#   SQL
#
#   execute <<~SQL
#     CREATE INDEX CONCURRENTLY IF NOT EXISTS
#     index_posts_on_image_upload_id ON posts USING btree (image_upload_id)
#   SQL
# end
#
# source://rubocop-discourse//lib/rubocop/cop/discourse/no_add_reference_active_record_migrations.rb#47
class RuboCop::Cop::Discourse::NoAddReferenceOrAliasesActiveRecordMigration < ::RuboCop::Cop::Cop
  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_add_reference_active_record_migrations.rb#72
  def on_send(node); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_add_reference_active_record_migrations.rb#60
  def using_add_belongs_to?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_add_reference_active_record_migrations.rb#56
  def using_add_reference?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_add_reference_active_record_migrations.rb#68
  def using_t_belongs_to?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_add_reference_active_record_migrations.rb#64
  def using_t_references?(param0 = T.unsafe(nil)); end
end

# source://rubocop-discourse//lib/rubocop/cop/discourse/no_add_reference_active_record_migrations.rb#48
RuboCop::Cop::Discourse::NoAddReferenceOrAliasesActiveRecordMigration::MSG = T.let(T.unsafe(nil), String)

# Avoid using chdir - it is not thread safe.
#
# Instead, you may be able to use:
# Discourse::Utils.execute_command(chdir: "test") do |runner|
#   runner.exec("pwd")
# end
#
# @example
#   # bad
#   Dir.chdir("test")
#
# source://rubocop-discourse//lib/rubocop/cop/discourse/no_chdir.rb#16
class RuboCop::Cop::Discourse::NoChdir < ::RuboCop::Cop::Cop
  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_chdir.rb#27
  def on_send(node); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_chdir.rb#19
  def using_dir_chdir?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_chdir.rb#23
  def using_fileutils_cd?(param0 = T.unsafe(nil)); end
end

# source://rubocop-discourse//lib/rubocop/cop/discourse/no_chdir.rb#17
RuboCop::Cop::Discourse::NoChdir::MSG = T.let(T.unsafe(nil), String)

# Use `type: :multisite` example setting instead of modifying `Rails.configuration.multisite`.
#
# @example
#   # bad
#   it "works" do
#   Rails.configuration.multisite = true
#   do_something
#   end
#
#   # good
#   it "works", type: :multisite do
#   do_something
#   end
#
# source://rubocop-discourse//lib/rubocop/cop/discourse/no_direct_multisite_manipulation.rb#19
class RuboCop::Cop::Discourse::NoDirectMultisiteManipulation < ::RuboCop::Cop::Cop
  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_direct_multisite_manipulation.rb#23
  def multisite_setter?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_direct_multisite_manipulation.rb#30
  def on_send(node); end
end

# source://rubocop-discourse//lib/rubocop/cop/discourse/no_direct_multisite_manipulation.rb#20
RuboCop::Cop::Discourse::NoDirectMultisiteManipulation::MSG = T.let(T.unsafe(nil), String)

# Use `response.parsed_body` instead of `JSON.parse(response.body)` in specs.
#
# @example
#   # bad
#   expect(::JSON.parse(response.body)).to eq({})
#
#   # good
#   expect(response.parsed_body).to eq({})
#
# source://rubocop-discourse//lib/rubocop/cop/discourse/no_json_parse_response.rb#14
class RuboCop::Cop::Discourse::NoJsonParseResponse < ::RuboCop::Cop::Cop
  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_json_parse_response.rb#31
  def autocorrect(node); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_json_parse_response.rb#18
  def json_parse_body?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_json_parse_response.rb#25
  def on_send(node); end
end

# source://rubocop-discourse//lib/rubocop/cop/discourse/no_json_parse_response.rb#15
RuboCop::Cop::Discourse::NoJsonParseResponse::MSG = T.let(T.unsafe(nil), String)

# Use `type: :multisite` only on a top-level `describe`.
# Mixing multisite and standard specs can lead to errors,
# e.g. when using `fab!` helper.
#
# @example
#   # bad
#   describe "x" do
#   end
#
#   describe "x", type: :multisite do
#   end
#
#   # good
#   # x_spec.rb
#   describe "x" do
#   end
#
#   # x_multisite_spec.rb
#   describe "x", type: :multisite do
#   end
#
# source://rubocop-discourse//lib/rubocop/cop/discourse/no_mixing_multisite_and_standard_specs.rb#26
class RuboCop::Cop::Discourse::NoMixingMultisiteAndStandardSpecs < ::RuboCop::Cop::Cop
  # @return [NoMixingMultisiteAndStandardSpecs] a new instance of NoMixingMultisiteAndStandardSpecs
  #
  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_mixing_multisite_and_standard_specs.rb#30
  def initialize(config = T.unsafe(nil), options = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_mixing_multisite_and_standard_specs.rb#50
  def describe?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_mixing_multisite_and_standard_specs.rb#58
  def multisite_describe?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_mixing_multisite_and_standard_specs.rb#35
  def on_block(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_mixing_multisite_and_standard_specs.rb#67
  def top_level?(node); end
end

# source://rubocop-discourse//lib/rubocop/cop/discourse/no_mixing_multisite_and_standard_specs.rb#27
RuboCop::Cop::Discourse::NoMixingMultisiteAndStandardSpecs::MSG = T.let(T.unsafe(nil), String)

# source://rubocop-discourse//lib/rubocop/cop/discourse/no_mocking_jobs.rb#6
class RuboCop::Cop::Discourse::NoMockingJobs < ::RuboCop::Cop::Cop
  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_mocking_jobs.rb#10
  def mocking_jobs_enqueue?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_mocking_jobs.rb#14
  def mocking_jobs_enqueue_in?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_mocking_jobs.rb#18
  def on_send(node); end
end

# source://rubocop-discourse//lib/rubocop/cop/discourse/no_mocking_jobs.rb#7
RuboCop::Cop::Discourse::NoMockingJobs::MSG = T.let(T.unsafe(nil), String)

# Do not use Nokogiri::HTML.fragment
# Instead use Nokogiri::HTML5.fragment, which is using Nokogumbo parser
#
# @example
#   # bad
#   Nokogiri::HTML.fragment("<p>test</p>")
#
#   # good
#   Nokogiri::HTML5.fragment("<p>test</p>")
#
# source://rubocop-discourse//lib/rubocop/cop/discourse/no_nokogiri_html_fragment.rb#15
class RuboCop::Cop::Discourse::NoNokogiriHtmlFragment < ::RuboCop::Cop::Cop
  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_nokogiri_html_fragment.rb#24
  def on_send(node); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_nokogiri_html_fragment.rb#18
  def using_nokogiri_html_fragment?(param0 = T.unsafe(nil)); end
end

# source://rubocop-discourse//lib/rubocop/cop/discourse/no_nokogiri_html_fragment.rb#16
RuboCop::Cop::Discourse::NoNokogiriHtmlFragment::MSG = T.let(T.unsafe(nil), String)

# Do not use `ActiveRecord::ModelSchema.reset_column_information` in
# migrations. The method is not thread safe and we run migrations
# concurrently for multisites. Also, we don't encourage the use of
# ActiveRecord methods in migrations and prefer to write SQL directly.
#
# source://rubocop-discourse//lib/rubocop/cop/discourse/no_reset_column_information_in_migrations.rb#10
class RuboCop::Cop::Discourse::NoResetColumnInformationInMigrations < ::RuboCop::Cop::Cop
  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_reset_column_information_in_migrations.rb#17
  def on_send(node); end
end

# source://rubocop-discourse//lib/rubocop/cop/discourse/no_reset_column_information_in_migrations.rb#11
RuboCop::Cop::Discourse::NoResetColumnInformationInMigrations::MSG = T.let(T.unsafe(nil), String)

# Use `Time.zone.now` instead of `Time.new` without arguments.
#
# @example
#   # bad
#   now = Time.new
#
#   # good
#   now = Time.zone.now
#
# source://rubocop-discourse//lib/rubocop/cop/discourse/no_time_new_without_args.rb#14
class RuboCop::Cop::Discourse::NoTimeNewWithoutArgs < ::RuboCop::Cop::Cop
  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_time_new_without_args.rb#27
  def autocorrect(node); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_time_new_without_args.rb#21
  def on_send(node); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_time_new_without_args.rb#17
  def time_new_without_args?(param0 = T.unsafe(nil)); end
end

# source://rubocop-discourse//lib/rubocop/cop/discourse/no_time_new_without_args.rb#15
RuboCop::Cop::Discourse::NoTimeNewWithoutArgs::MSG = T.let(T.unsafe(nil), String)

# Do not use URI.escape and its ilk, they are deprecated
# with a warning in the ruby source. Instead use
# Addressable::URI, which has encode, encode_component,
# and unencode methods. UrlHelper has helper methods for this.
#
# # @example
#   # bad
#   URI.encode("https://a%20a.com?a='a%22")
#
#   # good
#   UrlHelper.encode("https://a%20a.com?a='a%22")
#   Addressable::URI.encode("https://a%20a.com?a='a%22")
#
# source://rubocop-discourse//lib/rubocop/cop/discourse/no_uri_escape_encode.rb#18
class RuboCop::Cop::Discourse::NoURIEscapeEncode < ::RuboCop::Cop::Cop
  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_uri_escape_encode.rb#38
  def on_send(node); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_uri_escape_encode.rb#34
  def using_uri_decode?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_uri_escape_encode.rb#26
  def using_uri_encode?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_uri_escape_encode.rb#22
  def using_uri_escape?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/no_uri_escape_encode.rb#30
  def using_uri_unescape?(param0 = T.unsafe(nil)); end
end

# source://rubocop-discourse//lib/rubocop/cop/discourse/no_uri_escape_encode.rb#19
RuboCop::Cop::Discourse::NoURIEscapeEncode::MSG = T.let(T.unsafe(nil), String)

# Use `type: :multisite` only on a top-level `describe`.
# Mixing multisite and standard specs can lead to errors,
# e.g. when using `fab!` helper.
#
# @example
#   # bad
#   describe "something" do
#   describe "x", type: :multisite do
#   end
#
#   it "does X", type: :multisite do
#   end
#   end
#
#   # good
#   describe "something", type: :multisite do
#   describe "x" do
#   end
#
#   it "does X" do
#   end
#   end
#
# source://rubocop-discourse//lib/rubocop/cop/discourse/only_top_level_multisite_specs.rb#28
class RuboCop::Cop::Discourse::OnlyTopLevelMultisiteSpecs < ::RuboCop::Cop::Cop
  # source://rubocop-discourse//lib/rubocop/cop/discourse/only_top_level_multisite_specs.rb#40
  def multisite_describe?(param0 = T.unsafe(nil)); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/only_top_level_multisite_specs.rb#31
  def on_block(node); end

  private

  # @return [Boolean]
  #
  # source://rubocop-discourse//lib/rubocop/cop/discourse/only_top_level_multisite_specs.rb#49
  def top_level?(node); end
end

# source://rubocop-discourse//lib/rubocop/cop/discourse/only_top_level_multisite_specs.rb#29
RuboCop::Cop::Discourse::OnlyTopLevelMultisiteSpecs::MSG = T.let(T.unsafe(nil), String)

# Use `eq_time` matcher with timestamps in specs.
#
# @example
#   # bad
#   expect(user.created_at).to eq(Time.zone.now)
#
#   # good
#   expect(user.created_at).to eq_time(Time.zone.now)
#
# source://rubocop-discourse//lib/rubocop/cop/discourse/time_eq_matcher.rb#14
class RuboCop::Cop::Discourse::TimeEqMatcher < ::RuboCop::Cop::Cop
  # source://rubocop-discourse//lib/rubocop/cop/discourse/time_eq_matcher.rb#31
  def autocorrect(node); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/time_eq_matcher.rb#25
  def on_send(node); end

  # source://rubocop-discourse//lib/rubocop/cop/discourse/time_eq_matcher.rb#17
  def using_eq_matcher_with_timestamp?(param0 = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://rubocop-discourse//lib/rubocop/cop/discourse/time_eq_matcher.rb#43
  def not_nil?(expression); end

  # @return [Boolean]
  #
  # source://rubocop-discourse//lib/rubocop/cop/discourse/time_eq_matcher.rb#39
  def timestamp_suffix?(property); end
end

# source://rubocop-discourse//lib/rubocop/cop/discourse/time_eq_matcher.rb#15
RuboCop::Cop::Discourse::TimeEqMatcher::MSG = T.let(T.unsafe(nil), String)

# RuboCop Discourse project namespace
#
# source://rubocop-discourse//lib/rubocop/discourse.rb#5
module RuboCop::Discourse; end

# source://rubocop-discourse//lib/rubocop/discourse.rb#8
RuboCop::Discourse::CONFIG = T.let(T.unsafe(nil), Hash)

# source://rubocop-discourse//lib/rubocop/discourse.rb#7
RuboCop::Discourse::CONFIG_DEFAULT = T.let(T.unsafe(nil), Pathname)

# Because RuboCop doesn't yet support plugins, we have to monkey patch in a
# bit of our configuration.
#
# source://rubocop-discourse//lib/rubocop/discourse/inject.rb#7
module RuboCop::Discourse::Inject
  class << self
    # source://rubocop-discourse//lib/rubocop/discourse/inject.rb#8
    def defaults!; end
  end
end

# source://rubocop-discourse//lib/rubocop/discourse.rb#6
RuboCop::Discourse::PROJECT_ROOT = T.let(T.unsafe(nil), Pathname)
